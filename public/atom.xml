<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junedayday Blog</title>
  
  <subtitle>六月天天的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-18T09:49:31.728Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Junedayday</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【K8s源码品读】013：Phase 1 - kubelet - 节点上控制容器生命周期的管理者</title>
    <link href="http://example.com/2021/02/18/k8s-013/"/>
    <id>http://example.com/2021/02/18/k8s-013/</id>
    <published>2021-02-18T08:55:58.000Z</published>
    <updated>2021-02-18T09:49:31.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解 kubelet 的运行机制</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#Run">运行的主函数</a></li><li><a href="#RunKubelet">运行kubelet</a></li><li><a href="#Kubelet">核心数据管理Kubelet</a></li><li><a href="#syncLoop">同步循环</a></li><li><a href="#handler">处理pod的同步工作</a></li><li><a href="#Summary">总结</a></li></ol><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>从主函数找到run函数，代码较长，我精简了一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(ctx context.Context, s *options.KubeletServer, kubeDeps *kubelet.Dependencies, featureGate featuregate.FeatureGate)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 一长串的配置初始化与验证</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// done channel，用来通知运行结束</span></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册到configz模块</span></span><br><span class="line">err = initConfigz(&amp;s.KubeletConfiguration)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">&quot;unable to register KubeletConfiguration with configz, error: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取节点的相关信息</span></span><br><span class="line">hostName, err := nodeutil.GetHostname(s.HostnameOverride)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">nodeName, err := getNodeName(kubeDeps.Cloud, hostName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="comment">// 独立运行模式</span></span><br><span class="line"><span class="keyword">case</span> standaloneMode:</span><br><span class="line"><span class="comment">// 对客户端进行初始化</span></span><br><span class="line"><span class="keyword">case</span> kubeDeps.KubeClient == <span class="literal">nil</span>, kubeDeps.EventClient == <span class="literal">nil</span>, kubeDeps.HeartbeatClient == <span class="literal">nil</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cgroup 相关初始化</span></span><br><span class="line"><span class="keyword">var</span> cgroupRoots []<span class="keyword">string</span></span><br><span class="line">nodeAllocatableRoot := cm.NodeAllocatableRoot(s.CgroupRoot, s.CgroupsPerQOS, s.CgroupDriver)</span><br><span class="line">cgroupRoots = <span class="built_in">append</span>(cgroupRoots, nodeAllocatableRoot)</span><br><span class="line">kubeletCgroup, err := cm.GetKubeletContainer(s.KubeletCgroups)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Warningf(<span class="string">&quot;failed to get the kubelet&#x27;s cgroup: %v.  Kubelet system container metrics may be missing.&quot;</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> kubeletCgroup != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">cgroupRoots = <span class="built_in">append</span>(cgroupRoots, kubeletCgroup)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runtimeCgroup, err := cm.GetRuntimeContainer(s.ContainerRuntime, s.RuntimeCgroups)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Warningf(<span class="string">&quot;failed to get the container runtime&#x27;s cgroup: %v. Runtime system container metrics may be missing.&quot;</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> runtimeCgroup != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">cgroupRoots = <span class="built_in">append</span>(cgroupRoots, runtimeCgroup)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.SystemCgroups != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">cgroupRoots = <span class="built_in">append</span>(cgroupRoots, s.SystemCgroups)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面一大块都是对 ContainerManager 的初始化</span></span><br><span class="line"><span class="keyword">if</span> kubeDeps.ContainerManager == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.CgroupsPerQOS &amp;&amp; s.CgroupRoot == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">klog.Info(<span class="string">&quot;--cgroups-per-qos enabled, but --cgroup-root was not specified.  defaulting to /&quot;</span>)</span><br><span class="line">s.CgroupRoot = <span class="string">&quot;/&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// cpu相关信息</span></span><br><span class="line"><span class="keyword">var</span> reservedSystemCPUs cpuset.CPUSet</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ContainerManager的实例化</span></span><br><span class="line">kubeDeps.ContainerManager, err = cm.NewContainerManager(</span><br><span class="line">kubeDeps.Mounter,</span><br><span class="line">kubeDeps.CAdvisorInterface,</span><br><span class="line">      <span class="comment">// Node 相关配置</span></span><br><span class="line">cm.NodeConfig&#123;&#125;,</span><br><span class="line">s.FailSwapOn,</span><br><span class="line">devicePluginEnabled,</span><br><span class="line">kubeDeps.Recorder)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存OOM相关</span></span><br><span class="line">oomAdjuster := kubeDeps.OOMAdjuster</span><br><span class="line"><span class="keyword">if</span> err := oomAdjuster.ApplyOOMScoreAdj(<span class="number">0</span>, <span class="keyword">int</span>(s.OOMScoreAdj)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Warning(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预初始化Runtime</span></span><br><span class="line">err = kubelet.PreInitRuntimeService(&amp;s.KubeletConfiguration,</span><br><span class="line">kubeDeps, &amp;s.ContainerRuntimeOptions,</span><br><span class="line">s.ContainerRuntime,</span><br><span class="line">s.RuntimeCgroups,</span><br><span class="line">s.RemoteRuntimeEndpoint,</span><br><span class="line">s.RemoteImageEndpoint,</span><br><span class="line">s.NonMasqueradeCIDR)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行Kubelet</span></span><br><span class="line"><span class="keyword">if</span> err := RunKubelet(s, kubeDeps, s.RunOnce); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知deamon的systemd</span></span><br><span class="line"><span class="keyword">go</span> daemon.SdNotify(<span class="literal">false</span>, <span class="string">&quot;READY=1&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻塞</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RunKubelet"><a href="#RunKubelet" class="headerlink" title="RunKubelet"></a>RunKubelet</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunKubelet</span><span class="params">(kubeServer *options.KubeletServer, kubeDeps *kubelet.Dependencies, runOnce <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取节点信息</span></span><br><span class="line">  hostname, err := nodeutil.GetHostname(kubeServer.HostnameOverride)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">nodeName, err := getNodeName(kubeDeps.Cloud, hostname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">hostnameOverridden := <span class="built_in">len</span>(kubeServer.HostnameOverride) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建并初始化 kubelet</span></span><br><span class="line">k, err := createAndInitKubelet()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create kubelet: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> runOnce &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := k.RunOnce(podCfg.Updates()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;runonce failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">klog.Info(<span class="string">&quot;Started kubelet as runonce&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 开始kubelet</span></span><br><span class="line">startKubelet(k, podCfg, &amp;kubeServer.KubeletConfiguration, kubeDeps, kubeServer.EnableCAdvisorJSONEndpoints, kubeServer.EnableServer)</span><br><span class="line">klog.Info(<span class="string">&quot;Started kubelet&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始运行，都是并发的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startKubelet</span><span class="params">(k kubelet.Bootstrap, podCfg *config.PodConfig, kubeCfg *kubeletconfiginternal.KubeletConfiguration, kubeDeps *kubelet.Dependencies, enableCAdvisorJSONEndpoints, enableServer <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line"><span class="keyword">go</span> k.Run(podCfg.Updates())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启kubelet的http服务端</span></span><br><span class="line"><span class="keyword">if</span> enableServer &#123;</span><br><span class="line"><span class="keyword">go</span> k.ListenAndServe(net.ParseIP(kubeCfg.Address), <span class="keyword">uint</span>(kubeCfg.Port), kubeDeps.TLSOptions, kubeDeps.Auth,</span><br><span class="line">enableCAdvisorJSONEndpoints, kubeCfg.EnableDebuggingHandlers, kubeCfg.EnableContentionProfiling, kubeCfg.EnableSystemLogHandler)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 只读端口</span></span><br><span class="line"><span class="keyword">if</span> kubeCfg.ReadOnlyPort &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">go</span> k.ListenAndServeReadOnly(net.ParseIP(kubeCfg.Address), <span class="keyword">uint</span>(kubeCfg.ReadOnlyPort), enableCAdvisorJSONEndpoints)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.KubeletPodResources) &#123;</span><br><span class="line"><span class="keyword">go</span> k.ListenAndServePodResources()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的k是一个interface定义，我们需要回头看看</span></span><br><span class="line"><span class="keyword">type</span> Bootstrap <span class="keyword">interface</span> &#123;</span><br><span class="line">GetConfiguration() kubeletconfiginternal.KubeletConfiguration</span><br><span class="line">BirthCry()</span><br><span class="line">StartGarbageCollection()</span><br><span class="line">ListenAndServe(address net.IP, port <span class="keyword">uint</span>, tlsOptions *server.TLSOptions, auth server.AuthInterface, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableSystemLogHandler <span class="keyword">bool</span>)</span><br><span class="line">ListenAndServeReadOnly(address net.IP, port <span class="keyword">uint</span>, enableCAdvisorJSONEndpoints <span class="keyword">bool</span>)</span><br><span class="line">ListenAndServePodResources()</span><br><span class="line">Run(&lt;-<span class="keyword">chan</span> kubetypes.PodUpdate)</span><br><span class="line">RunOnce(&lt;-<span class="keyword">chan</span> kubetypes.PodUpdate) ([]RunPodResult, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看对应的实例化函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAndInitKubelet</span><span class="params">()</span> <span class="params">(k kubelet.Bootstrap, err error)</span></span> &#123;</span><br><span class="line">k, err = kubelet.NewMainKubelet()</span><br><span class="line"><span class="keyword">return</span> k, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMainKubelet</span><span class="params">()</span> <span class="params">(*Kubelet, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 参数的初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// klet 的实例化结构</span></span><br><span class="line">klet := &amp;Kubelet&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是klet中各种参数的填充</span></span><br><span class="line"><span class="keyword">return</span> klet, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">Run</span><span class="params">(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate)</span></span> &#123;</span><br><span class="line"><span class="comment">// 内部模块的初始化</span></span><br><span class="line"><span class="keyword">if</span> err := kl.initializeModules(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.recorder.Eventf(kl.nodeRef, v1.EventTypeWarning, events.KubeletSetupFailed, err.Error())</span><br><span class="line">klog.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> kl.kubeClient != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 与kube-apiserver同步节点状态</span></span><br><span class="line"><span class="keyword">go</span> wait.Until(kl.syncNodeStatus, kl.nodeStatusUpdateFrequency, wait.NeverStop)</span><br><span class="line"><span class="keyword">go</span> kl.fastStatusUpdateOnce()</span><br><span class="line"><span class="keyword">go</span> kl.nodeLeaseController.Run(wait.NeverStop)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> wait.Until(kl.updateRuntimeUp, <span class="number">5</span>*time.Second, wait.NeverStop)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> kl.makeIPTablesUtilChains &#123;</span><br><span class="line">kl.initNetworkUtil()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个kill pod的goroutine</span></span><br><span class="line"><span class="keyword">go</span> wait.Until(kl.podKiller.PerformPodKillingWork, <span class="number">1</span>*time.Second, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">kl.statusManager.Start()</span><br><span class="line">kl.probeManager.Start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> kl.runtimeClassManager != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.runtimeClassManager.Start(wait.NeverStop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kl.pleg.Start()</span><br><span class="line">  <span class="comment">// 同步的主逻辑</span></span><br><span class="line">kl.syncLoop(updates, kl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="syncLoop"><a href="#syncLoop" class="headerlink" title="syncLoop"></a>syncLoop</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncLoop</span><span class="params">(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 开始运行kubelet的主同步循环</span></span><br><span class="line">klog.Info(<span class="string">&quot;Starting kubelet main sync loop.&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ticker每秒一次</span></span><br><span class="line">syncTicker := time.NewTicker(time.Second)</span><br><span class="line"><span class="keyword">defer</span> syncTicker.Stop()</span><br><span class="line">  <span class="comment">// housekeeping 清理周期</span></span><br><span class="line">housekeepingTicker := time.NewTicker(housekeepingPeriod)</span><br><span class="line"><span class="keyword">defer</span> housekeepingTicker.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line"><span class="keyword">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的3个channel比较重要：configCh用于配置，syncCh用于触发同步，housekeepingCh用于触发清理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncLoopIteration</span><span class="params">(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> u, open := &lt;-configCh:</span><br><span class="line">    <span class="comment">// config channel关闭</span></span><br><span class="line"><span class="keyword">if</span> !open &#123;</span><br><span class="line">klog.Errorf(<span class="string">&quot;Update channel is closed. Exiting the sync loop.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应不同的操作</span></span><br><span class="line"><span class="keyword">switch</span> u.Op &#123;</span><br><span class="line"><span class="keyword">case</span> kubetypes.ADD:</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;SyncLoop (ADD, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">handler.HandlePodAdditions(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.UPDATE:</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;SyncLoop (UPDATE, %q): %q&quot;</span>, u.Source, format.PodsWithDeletionTimestamps(u.Pods))</span><br><span class="line">handler.HandlePodUpdates(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.REMOVE:</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;SyncLoop (REMOVE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">handler.HandlePodRemoves(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.RECONCILE:</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;SyncLoop (RECONCILE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">handler.HandlePodReconcile(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.DELETE:</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;SyncLoop (DELETE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">handler.HandlePodUpdates(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.SET:</span><br><span class="line">klog.Errorf(<span class="string">&quot;Kubelet does not support snapshot update&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">klog.Errorf(<span class="string">&quot;Invalid event type received: %d.&quot;</span>, u.Op)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kl.sourcesReady.AddSource(u.Source)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> e := &lt;-plegCh:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-syncCh:</span><br><span class="line"><span class="comment">// 获取需要同步的pod，里面的逻辑暂不细看</span></span><br><span class="line">    <span class="comment">// 我们在这里接收到示例中要创建的nginx pod</span></span><br><span class="line">podsToSync := kl.getPodsToSync()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(podsToSync) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;SyncLoop (SYNC): %d pods; %s&quot;</span>, <span class="built_in">len</span>(podsToSync), format.Pods(podsToSync))</span><br><span class="line">    <span class="comment">// 开始处理</span></span><br><span class="line">handler.HandlePodSyncs(podsToSync)</span><br><span class="line"><span class="keyword">case</span> update := &lt;-kl.livenessManager.Updates():</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-housekeepingCh:</span><br><span class="line"><span class="keyword">if</span> !kl.sourcesReady.AllReady() &#123;</span><br><span class="line">      <span class="comment">// 清理没有ready，直接跳过</span></span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;SyncLoop (housekeeping, skipped): sources aren&#x27;t ready yet.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 开始清理pod</span></span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;SyncLoop (housekeeping)&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err := handler.HandlePodCleanups(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">&quot;Failed cleaning pods: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p>往前查找代码，handler就是Kubelet</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodSyncs</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">start := kl.clock.Now()</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">    <span class="comment">// 获取pod，然后分发</span></span><br><span class="line">mirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)</span><br><span class="line">kl.dispatchWork(pod, kubetypes.SyncPodSync, mirrorPod, start)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">dispatchWork</span><span class="params">(pod *v1.Pod, syncType kubetypes.SyncPodType, mirrorPod *v1.Pod, start time.Time)</span></span> &#123;</span><br><span class="line"><span class="comment">// 调用UpdatePod的函数</span></span><br><span class="line">kl.podWorkers.UpdatePod(&amp;UpdatePodOptions&#123;</span><br><span class="line">Pod:        pod,</span><br><span class="line">MirrorPod:  mirrorPod,</span><br><span class="line">UpdateType: syncType,</span><br><span class="line">OnCompleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">metrics.PodWorkerDuration.WithLabelValues(syncType.String()).Observe(metrics.SinceInSeconds(start))</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查到初始化的地方 klet.podWorkers = newPodWorkers(klet.syncPod, kubeDeps.Recorder, klet.workQueue, klet.resyncInterval, backOffPeriod, klet.podCache)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span> <span class="title">UpdatePod</span><span class="params">(options *UpdatePodOptions)</span></span> &#123;</span><br><span class="line">pod := options.Pod</span><br><span class="line">uid := pod.UID</span><br><span class="line"><span class="keyword">var</span> podUpdates <span class="keyword">chan</span> UpdatePodOptions</span><br><span class="line"><span class="keyword">var</span> exists <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">p.podLock.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.podLock.Unlock()</span><br><span class="line">  <span class="comment">// 当pod不存在时，满足示例，是新建的pod</span></span><br><span class="line"><span class="keyword">if</span> podUpdates, exists = p.podUpdates[uid]; !exists &#123;</span><br><span class="line">podUpdates = <span class="built_in">make</span>(<span class="keyword">chan</span> UpdatePodOptions, <span class="number">1</span>)</span><br><span class="line">p.podUpdates[uid] = podUpdates</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发处理</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> runtime.HandleCrash()</span><br><span class="line">p.managePodLoop(podUpdates)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !p.isWorking[pod.UID] &#123;</span><br><span class="line">p.isWorking[pod.UID] = <span class="literal">true</span></span><br><span class="line">podUpdates &lt;- *options</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">update, found := p.lastUndeliveredWorkUpdate[pod.UID]</span><br><span class="line"><span class="keyword">if</span> !found || update.UpdateType != kubetypes.SyncPodKill &#123;</span><br><span class="line">p.lastUndeliveredWorkUpdate[pod.UID] = *options</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span> <span class="title">managePodLoop</span><span class="params">(podUpdates &lt;-<span class="keyword">chan</span> UpdatePodOptions)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> lastSyncTime time.Time</span><br><span class="line"><span class="keyword">for</span> update := <span class="keyword">range</span> podUpdates &#123;</span><br><span class="line">err := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">      <span class="comment">// 同步pod的函数</span></span><br><span class="line">err = p.syncPodFn(syncPodOptions&#123;</span><br><span class="line">mirrorPod:      update.MirrorPod,</span><br><span class="line">pod:            update.Pod,</span><br><span class="line">podStatus:      status,</span><br><span class="line">killPodOptions: update.KillPodOptions,</span><br><span class="line">updateType:     update.UpdateType,</span><br><span class="line">&#125;)</span><br><span class="line">lastSyncTime = time.Now()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">p.wrapUp(update.Pod.UID, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到syncPodFn被实例化的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncPod</span><span class="params">(o syncPodOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里有一长串逻辑，不方便阅读，我们只关注最核心的部分</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用 container runtime进行创建pod，再往下就是容器相关了</span></span><br><span class="line">result := kl.containerRuntime.SyncPod(pod, podStatus, pullSecrets, kl.backOff)</span><br><span class="line">kl.reasonCache.Update(pod.UID, result)</span><br><span class="line"><span class="keyword">if</span> err := result.Error(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> result.SyncResults &#123;</span><br><span class="line"><span class="keyword">if</span> r.Error != kubecontainer.ErrCrashLoopBackOff &amp;&amp; r.Error != images.ErrImagePullBackOff &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol><li><p><code>kubelet</code>是kubernetes的<code>Node</code>节点上的管理者</p></li><li><p><code>kubelet</code>接收来自<code>kube-apiserver</code>上的pod消息，用<code>Ticker</code>这种周期性的方式触发同步函数</p></li><li><code>kubelet</code>会异步地对容器进行管理，调用对应容器的接口（Container Runtime Interface）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚焦目标&quot;&gt;&lt;a href=&quot;#聚焦目标&quot; class=&quot;headerlink&quot; title=&quot;聚焦目标&quot;&gt;&lt;/a&gt;聚焦目标&lt;/h2&gt;&lt;p&gt;理解 kubelet 的运行机制&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="源码阅读" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Kubernetes" scheme="http://example.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>【K8s源码品读】012：Phase 1 - kube-controller-manager - 了解控制管理中心</title>
    <link href="http://example.com/2021/02/18/k8s-012/"/>
    <id>http://example.com/2021/02/18/k8s-012/</id>
    <published>2021-02-18T08:55:57.000Z</published>
    <updated>2021-02-18T09:00:51.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解 kube-controller-manager 的运行机制</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#Run">运行的主函数</a></li><li><a href="#StartControllers">控制器的启动函数</a></li><li><a href="#ReplicaSet">引入概念ReplicaSet</a></li><li><a href="#ReplicaSetController">查看ReplicaSetController</a></li><li><a href="#syncReplicaSet">ReplicaSet的核心实现函数</a></li><li><a href="#Summary">总结</a></li></ol><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>我们找到了对应的主函数，看看其中的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c *config.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// configz 模块，在kube-scheduler分析中已经了解</span></span><br><span class="line"><span class="keyword">if</span> cfgz, err := configz.New(ConfigzName); err == <span class="literal">nil</span> &#123;</span><br><span class="line">cfgz.Set(c.ComponentConfig)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">&quot;unable to register configz: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 健康监测与http服务，跳过</span></span><br><span class="line"><span class="keyword">var</span> checks []healthz.HealthChecker</span><br><span class="line"><span class="keyword">var</span> unsecuredMux *mux.PathRecorderMux</span><br><span class="line"></span><br><span class="line">run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">rootClientBuilder := controller.SimpleControllerClientBuilder&#123;</span><br><span class="line">ClientConfig: c.Kubeconfig,</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// client认证相关</span></span><br><span class="line"><span class="keyword">var</span> clientBuilder controller.ControllerClientBuilder</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建controller的上下文context</span></span><br><span class="line">controllerContext, err := CreateControllerContext(c, rootClientBuilder, clientBuilder, ctx.Done())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">&quot;error building controller context: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">saTokenControllerInitFunc := serviceAccountTokenControllerStarter&#123;rootClientBuilder: rootClientBuilder&#125;.startServiceAccountTokenController</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := StartControllers(controllerContext, saTokenControllerInitFunc, NewControllerInitializers(controllerContext.LoopMode), unsecuredMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">&quot;error starting controllers: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 InformerFactory 和我们在kube-scheduler中看的 SharedInformerFactory 基本一致</span></span><br><span class="line">controllerContext.InformerFactory.Start(controllerContext.Stop)</span><br><span class="line">controllerContext.ObjectOrMetadataInformerFactory.Start(controllerContext.Stop)</span><br><span class="line"><span class="built_in">close</span>(controllerContext.InformersStarted)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否进行选举</span></span><br><span class="line"><span class="keyword">if</span> !c.ComponentConfig.Generic.LeaderElection.LeaderElect &#123;</span><br><span class="line">run(context.TODO())</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼接出一个全局唯一的id</span></span><br><span class="line">id, err := os.Hostname()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">id = id + <span class="string">&quot;_&quot;</span> + <span class="keyword">string</span>(uuid.NewUUID())</span><br><span class="line"></span><br><span class="line">rl, err := resourcelock.New(c.ComponentConfig.Generic.LeaderElection.ResourceLock,</span><br><span class="line">c.ComponentConfig.Generic.LeaderElection.ResourceNamespace,</span><br><span class="line">c.ComponentConfig.Generic.LeaderElection.ResourceName,</span><br><span class="line">c.LeaderElectionClient.CoreV1(),</span><br><span class="line">c.LeaderElectionClient.CoordinationV1(),</span><br><span class="line">resourcelock.ResourceLockConfig&#123;</span><br><span class="line">Identity:      id,</span><br><span class="line">EventRecorder: c.EventRecorder,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">&quot;error creating lock: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正常情况下都是阻塞在RunOrDie这个函数中，不停地进行选举相关的工作</span></span><br><span class="line">leaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig&#123;</span><br><span class="line">Lock:          rl,</span><br><span class="line">LeaseDuration: c.ComponentConfig.Generic.LeaderElection.LeaseDuration.Duration,</span><br><span class="line">RenewDeadline: c.ComponentConfig.Generic.LeaderElection.RenewDeadline.Duration,</span><br><span class="line">RetryPeriod:   c.ComponentConfig.Generic.LeaderElection.RetryPeriod.Duration,</span><br><span class="line">Callbacks: leaderelection.LeaderCallbacks&#123;</span><br><span class="line">      <span class="comment">// 开始成为Leader的时候，调用run函数</span></span><br><span class="line">OnStartedLeading: run,</span><br><span class="line">OnStoppedLeading: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">&quot;leaderelection lost&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">WatchDog: electionChecker,</span><br><span class="line">Name:     <span class="string">&quot;kube-controller-manager&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StartControllers"><a href="#StartControllers" class="headerlink" title="StartControllers"></a>StartControllers</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartControllers</span><span class="params">(ctx ControllerContext, startSATokenController InitFunc, controllers <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc, unsecuredMux *mux.PathRecorderMux)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 关键性的循环，启动每个controllers，key为控制器名字，value为初始化函数</span></span><br><span class="line"><span class="keyword">for</span> controllerName, initFn := <span class="keyword">range</span> controllers &#123;</span><br><span class="line">    <span class="comment">// 是否允许启动</span></span><br><span class="line"><span class="keyword">if</span> !ctx.IsControllerEnabled(controllerName) &#123;</span><br><span class="line">klog.Warningf(<span class="string">&quot;%q is disabled&quot;</span>, controllerName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(wait.Jitter(ctx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))</span><br><span class="line">klog.V(<span class="number">1</span>).Infof(<span class="string">&quot;Starting %q&quot;</span>, controllerName)</span><br><span class="line">    <span class="comment">// 调用init函数进行启动</span></span><br><span class="line">debugHandler, started, err := initFn(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">&quot;Error starting %q&quot;</span>, controllerName)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !started &#123;</span><br><span class="line">klog.Warningf(<span class="string">&quot;Skipping %q&quot;</span>, controllerName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 注册对应controller到debug的url中</span></span><br><span class="line"><span class="keyword">if</span> debugHandler != <span class="literal">nil</span> &amp;&amp; unsecuredMux != <span class="literal">nil</span> &#123;</span><br><span class="line">basePath := <span class="string">&quot;/debug/controllers/&quot;</span> + controllerName</span><br><span class="line">unsecuredMux.UnlistedHandle(basePath, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">unsecuredMux.UnlistedHandlePrefix(basePath+<span class="string">&quot;/&quot;</span>, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">&#125;</span><br><span class="line">klog.Infof(<span class="string">&quot;Started %q&quot;</span>, controllerName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再去传入controller的函数去看看，对应的controller有哪些，这里有我们很多常见的概念，今天不一一细讲</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">controllers := <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc&#123;&#125;</span><br><span class="line">controllers[<span class="string">&quot;endpoint&quot;</span>] = startEndpointController</span><br><span class="line">controllers[<span class="string">&quot;endpointslice&quot;</span>] = startEndpointSliceController</span><br><span class="line">controllers[<span class="string">&quot;endpointslicemirroring&quot;</span>] = startEndpointSliceMirroringController</span><br><span class="line">controllers[<span class="string">&quot;replicationcontroller&quot;</span>] = startReplicationController</span><br><span class="line">controllers[<span class="string">&quot;podgc&quot;</span>] = startPodGCController</span><br><span class="line">controllers[<span class="string">&quot;resourcequota&quot;</span>] = startResourceQuotaController</span><br><span class="line">controllers[<span class="string">&quot;namespace&quot;</span>] = startNamespaceController</span><br><span class="line">controllers[<span class="string">&quot;serviceaccount&quot;</span>] = startServiceAccountController</span><br><span class="line">controllers[<span class="string">&quot;garbagecollector&quot;</span>] = startGarbageCollectorController</span><br><span class="line">controllers[<span class="string">&quot;daemonset&quot;</span>] = startDaemonSetController</span><br><span class="line">controllers[<span class="string">&quot;job&quot;</span>] = startJobController</span><br><span class="line">controllers[<span class="string">&quot;deployment&quot;</span>] = startDeploymentController</span><br><span class="line">controllers[<span class="string">&quot;replicaset&quot;</span>] = startReplicaSetController</span><br><span class="line">controllers[<span class="string">&quot;horizontalpodautoscaling&quot;</span>] = startHPAController</span><br><span class="line">controllers[<span class="string">&quot;disruption&quot;</span>] = startDisruptionController</span><br><span class="line">controllers[<span class="string">&quot;statefulset&quot;</span>] = startStatefulSetController</span><br><span class="line">controllers[<span class="string">&quot;cronjob&quot;</span>] = startCronJobController</span><br><span class="line">controllers[<span class="string">&quot;csrsigning&quot;</span>] = startCSRSigningController</span><br><span class="line">controllers[<span class="string">&quot;csrapproving&quot;</span>] = startCSRApprovingController</span><br><span class="line">controllers[<span class="string">&quot;csrcleaner&quot;</span>] = startCSRCleanerController</span><br><span class="line">controllers[<span class="string">&quot;ttl&quot;</span>] = startTTLController</span><br><span class="line">controllers[<span class="string">&quot;bootstrapsigner&quot;</span>] = startBootstrapSignerController</span><br><span class="line">controllers[<span class="string">&quot;tokencleaner&quot;</span>] = startTokenCleanerController</span><br><span class="line">controllers[<span class="string">&quot;nodeipam&quot;</span>] = startNodeIpamController</span><br><span class="line">controllers[<span class="string">&quot;nodelifecycle&quot;</span>] = startNodeLifecycleController</span><br><span class="line"><span class="keyword">if</span> loopMode == IncludeCloudLoops &#123;</span><br><span class="line">controllers[<span class="string">&quot;service&quot;</span>] = startServiceController</span><br><span class="line">controllers[<span class="string">&quot;route&quot;</span>] = startRouteController</span><br><span class="line">controllers[<span class="string">&quot;cloud-node-lifecycle&quot;</span>] = startCloudNodeLifecycleController</span><br><span class="line">&#125;</span><br><span class="line">controllers[<span class="string">&quot;persistentvolume-binder&quot;</span>] = startPersistentVolumeBinderController</span><br><span class="line">controllers[<span class="string">&quot;attachdetach&quot;</span>] = startAttachDetachController</span><br><span class="line">controllers[<span class="string">&quot;persistentvolume-expander&quot;</span>] = startVolumeExpandController</span><br><span class="line">controllers[<span class="string">&quot;clusterrole-aggregation&quot;</span>] = startClusterRoleAggregrationController</span><br><span class="line">controllers[<span class="string">&quot;pvc-protection&quot;</span>] = startPVCProtectionController</span><br><span class="line">controllers[<span class="string">&quot;pv-protection&quot;</span>] = startPVProtectionController</span><br><span class="line">controllers[<span class="string">&quot;ttl-after-finished&quot;</span>] = startTTLAfterFinishedController</span><br><span class="line">controllers[<span class="string">&quot;root-ca-cert-publisher&quot;</span>] = startRootCACertPublisher</span><br><span class="line">controllers[<span class="string">&quot;ephemeral-volume&quot;</span>] = startEphemeralVolumeController</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> controllers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><p>由于我们的示例是创建一个nginx的pod，涉及到kube-controller-manager的内容很少。</p><p>但是，为了加深大家对 kube-controller-manager 的认识，我们引入一个新的概念 - ReplicaSet，下面是官方说明：</p><blockquote><p>A ReplicaSet’s purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.</p></blockquote><blockquote><p>ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p></blockquote><p>简单来说，ReplicaSet 就是用来生成指定个数的Pod。</p><h2 id="ReplicaSetController"><a href="#ReplicaSetController" class="headerlink" title="ReplicaSetController"></a>ReplicaSetController</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startReplicaSetController</span><span class="params">(ctx ControllerContext)</span> <span class="params">(http.Handler, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !ctx.AvailableResources[schema.GroupVersionResource&#123;Group: <span class="string">&quot;apps&quot;</span>, Version: <span class="string">&quot;v1&quot;</span>, Resource: <span class="string">&quot;replicasets&quot;</span>&#125;] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用goroutine异步运行，包含了 ReplicaSet和Pod 的两个Informer</span></span><br><span class="line">  <span class="comment">// 这一点很好理解：我们是要控制ReplicaSet声明的数量和运行的Pod数量一致，需要同时观察者两种资源</span></span><br><span class="line"><span class="keyword">go</span> replicaset.NewReplicaSetController(</span><br><span class="line">ctx.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">ctx.InformerFactory.Core().V1().Pods(),</span><br><span class="line">ctx.ClientBuilder.ClientOrDie(<span class="string">&quot;replicaset-controller&quot;</span>),</span><br><span class="line">replicaset.BurstReplicas,</span><br><span class="line">).Run(<span class="keyword">int</span>(ctx.ComponentConfig.ReplicaSetController.ConcurrentRSSyncs), ctx.Stop)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"><span class="keyword">defer</span> rsc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">controllerName := strings.ToLower(rsc.Kind)</span><br><span class="line">klog.Infof(<span class="string">&quot;Starting %v controller&quot;</span>, controllerName)</span><br><span class="line"><span class="keyword">defer</span> klog.Infof(<span class="string">&quot;Shutting down %v controller&quot;</span>, controllerName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !cache.WaitForNamedCacheSync(rsc.Kind, stopCh, rsc.podListerSynced, rsc.rsListerSynced) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">    <span class="comment">// 工作的函数</span></span><br><span class="line"><span class="keyword">go</span> wait.Until(rsc.worker, time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-stopCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 继续查找实现</span></span><br><span class="line"><span class="keyword">for</span> rsc.processNextWorkItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里也有个queue的概念，可以类比kube-scheduler中的实现</span></span><br><span class="line">  <span class="comment">// 不同的是，这里的queue是 workqueue.RateLimitingInterface ，也就是限制速率的，具体实现今天不细看</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取元素</span></span><br><span class="line">key, quit := rsc.queue.Get()</span><br><span class="line"><span class="keyword">if</span> quit &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rsc.queue.Done(key)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理对应的元素</span></span><br><span class="line">err := rsc.syncHandler(key.(<span class="keyword">string</span>))</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">rsc.queue.Forget(key)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;sync %q failed with %v&quot;</span>, key, err))</span><br><span class="line">rsc.queue.AddRateLimited(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再回过头，去查看syncHandler的具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBaseController</span><span class="params">(rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, kubeClient clientset.Interface, burstReplicas <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">gvk schema.GroupVersionKind, metricOwnerName, queueName <span class="keyword">string</span>, podControl controller.PodControlInterface)</span> *<span class="title">ReplicaSetController</span></span> &#123;</span><br><span class="line"></span><br><span class="line">rsc.syncHandler = rsc.syncReplicaSet</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rsc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="syncReplicaSet"><a href="#syncReplicaSet" class="headerlink" title="syncReplicaSet"></a>syncReplicaSet</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">syncReplicaSet</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">startTime := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Finished syncing %v %q (%v)&quot;</span>, rsc.Kind, key, time.Since(startTime))</span><br><span class="line">&#125;()</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 从key中拆分出 namespace 和 name</span></span><br><span class="line">namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据name，从 Lister 获取对应的 ReplicaSets 信息</span></span><br><span class="line">rs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)</span><br><span class="line"><span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;%v %v has been deleted&quot;</span>, rsc.Kind, key)</span><br><span class="line">rsc.expectations.DeleteExpectations(key)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rsNeedsSync := rsc.expectations.SatisfiedExpectations(key)</span><br><span class="line">  <span class="comment">// 获取 selector (k8s 是根据selector中的label来匹配 ReplicaSets 和 Pod 的)</span></span><br><span class="line">selector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;error converting pod selector to selector: %v&quot;</span>, err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据namespace和labels获取所有的pod</span></span><br><span class="line">allPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 过滤无效的pod</span></span><br><span class="line">filteredPods := controller.FilterActivePods(allPods)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据selector再过滤pod</span></span><br><span class="line">filteredPods, err = rsc.claimPods(rs, selector, filteredPods)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manageReplicasErr error</span><br><span class="line"><span class="keyword">if</span> rsNeedsSync &amp;&amp; rs.DeletionTimestamp == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 管理 ReplicaSet，下面详细分析</span></span><br><span class="line">manageReplicasErr = rsc.manageReplicas(filteredPods, rs)</span><br><span class="line">&#125;</span><br><span class="line">rs = rs.DeepCopy()</span><br><span class="line">newStatus := calculateStatus(rs, filteredPods, manageReplicasErr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新状态</span></span><br><span class="line">updatedRS, err := updateReplicaSetStatus(rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace), rs, newStatus)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> manageReplicasErr == <span class="literal">nil</span> &amp;&amp; updatedRS.Spec.MinReadySeconds &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">updatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &amp;&amp;</span><br><span class="line">updatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) &#123;</span><br><span class="line">rsc.queue.AddAfter(key, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> manageReplicasErr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再一起看看，当Pod数量和ReplicaSet中声明的不同时，是怎么工作的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">manageReplicas</span><span class="params">(filteredPods []*v1.Pod, rs *apps.ReplicaSet)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// diff = 当前pod数 - 期望pod数</span></span><br><span class="line">  diff := <span class="built_in">len</span>(filteredPods) - <span class="keyword">int</span>(*(rs.Spec.Replicas))</span><br><span class="line">rsKey, err := controller.KeyFunc(rs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;couldn&#x27;t get key for %v %#v: %v&quot;</span>, rsc.Kind, rs, err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// diff小于0，表示需要扩容，即新增Pod</span></span><br><span class="line"><span class="keyword">if</span> diff &lt; <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体的实现暂时不细看</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// diff 大于0，即需要缩容</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> diff &gt; <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>kube-controller-manager 的核心思想是： 根据<code>期望状态</code>和<code>当前状态</code>，管理Kubernetes中的资源。</p><p>以ReplicaSet为例，它对比了<code>定义声明的Pod数</code>和<code>当前集群中满足条件的Pod数</code>，进行相对应的扩缩容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚焦目标&quot;&gt;&lt;a href=&quot;#聚焦目标&quot; class=&quot;headerlink&quot; title=&quot;聚焦目标&quot;&gt;&lt;/a&gt;聚焦目标&lt;/h2&gt;&lt;p&gt;理解 kube-controller-manager 的运行机制&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【K8s源码品读】011：Phase 1 - kube-scheduler - 了解分配pod的大致流程</title>
    <link href="http://example.com/2021/02/18/k8s-011/"/>
    <id>http://example.com/2021/02/18/k8s-011/</id>
    <published>2021-02-18T08:55:56.000Z</published>
    <updated>2021-02-18T09:00:34.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解一个pod的被调度的大致流程 </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#Scheduler">分析Scheduler的结构体</a></li><li><a href="#SchedulingQueue">往SchedulingQueue里</a></li><li><a href="#scheduleOne">调度一个pod对象</a><ol><li><a href="#ScheduleResult">调度计算结果 - ScheduleResult</a></li><li><a href="#Assume">初步推算 - Assume</a></li><li><a href="#Bind">实际绑定 - Bind</a></li></ol></li><li><a href="#update-to-etcd">将绑定成功后的数据更新到etcd</a></li><li><a href="#Summary">pod绑定Node的总结</a></li></ol><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>在前面，我们了解了<code>Pod调度算法的注册</code>和<code>Informer机制来监听kube-apiserver上的资源变化</code>，今天这一讲，我们就将两者串联起来，看看在kube-scheduler中，Informer监听到资源变化后，如何用调度算法将pod进行调度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在运行 kube-scheduler 的初期，我们创建了一个Scheduler的数据结构，回头再看看有什么和pod调度算法相关的</span></span><br><span class="line"><span class="keyword">type</span> Scheduler <span class="keyword">struct</span> &#123;</span><br><span class="line">SchedulerCache internalcache.Cache</span><br><span class="line">Algorithm core.ScheduleAlgorithm</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个需要调度的Pod</span></span><br><span class="line">NextPod <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">framework</span>.<span class="title">QueuedPodInfo</span></span></span><br><span class="line"></span><br><span class="line">Error <span class="function"><span class="keyword">func</span><span class="params">(*framework.QueuedPodInfo, error)</span></span></span><br><span class="line">StopEverything &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待调度的Pod队列，我们重点看看这个队列是什么</span></span><br><span class="line">SchedulingQueue internalqueue.SchedulingQueue</span><br><span class="line"></span><br><span class="line">Profiles profile.Map</span><br><span class="line">scheduledPodsHasSynced <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">client clientset.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scheduler的实例化函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sched *Scheduler</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="comment">// 从 Provider 创建</span></span><br><span class="line"><span class="keyword">case</span> source.Provider != <span class="literal">nil</span>:</span><br><span class="line">sc, err := configurator.createFromProvider(*source.Provider)</span><br><span class="line">sched = sc</span><br><span class="line">  <span class="comment">// 从文件或者ConfigMap中创建</span></span><br><span class="line"><span class="keyword">case</span> source.Policy != <span class="literal">nil</span>:</span><br><span class="line">sc, err := configurator.createFromConfig(*policy)</span><br><span class="line">sched = sc</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unsupported algorithm source: %v&quot;</span>, source)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个创建方式，底层都是调用的 create 函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">createFromProvider</span><span class="params">(providerName <span class="keyword">string</span>)</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.create()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">createFromConfig</span><span class="params">(policy schedulerapi.Policy)</span> <span class="params">(*Scheduler, error)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c.create()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">create</span><span class="params">()</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 实例化 podQueue</span></span><br><span class="line">podQueue := internalqueue.NewSchedulingQueue(</span><br><span class="line">lessFn,</span><br><span class="line">internalqueue.WithPodInitialBackoffDuration(time.Duration(c.podInitialBackoffSeconds)*time.Second),</span><br><span class="line">internalqueue.WithPodMaxBackoffDuration(time.Duration(c.podMaxBackoffSeconds)*time.Second),</span><br><span class="line">internalqueue.WithPodNominator(nominator),</span><br><span class="line">)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> &amp;Scheduler&#123;</span><br><span class="line">SchedulerCache:  c.schedulerCache,</span><br><span class="line">Algorithm:       algo,</span><br><span class="line">Profiles:        profiles,</span><br><span class="line">    <span class="comment">// NextPod 函数依赖于 podQueue</span></span><br><span class="line">NextPod:         internalqueue.MakeNextPodFunc(podQueue),</span><br><span class="line">Error:           MakeDefaultErrorFunc(c.client, c.informerFactory.Core().V1().Pods().Lister(), podQueue, c.schedulerCache),</span><br><span class="line">StopEverything:  c.StopEverything,</span><br><span class="line">    <span class="comment">// 调度队列被赋值为podQueue</span></span><br><span class="line">SchedulingQueue: podQueue,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再看看这个调度队列的初始化函数，从命名可以看到是一个优先队列，它的实现细节暂不细看</span></span><br><span class="line"><span class="comment">// 结合实际情况思考下，pod会有重要程度的区分，所以调度的顺序需要考虑优先级的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSchedulingQueue</span><span class="params">(lessFn framework.LessFunc, opts ...Option)</span> <span class="title">SchedulingQueue</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewPriorityQueue(lessFn, opts...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SchedulingQueue"><a href="#SchedulingQueue" class="headerlink" title="SchedulingQueue"></a>SchedulingQueue</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在上面实例化Scheduler后，有个注册事件 Handler 的函数：addAllEventHandlers(sched, informerFactory, podInformer)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addAllEventHandlers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">sched *Scheduler,</span></span></span><br><span class="line"><span class="function"><span class="params">informerFactory informers.SharedInformerFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数前后有很多注册的Handler，但是和未调度pod添加到队列相关的，只有这个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">podInformer.Informer().AddEventHandler(</span><br><span class="line">cache.FilteringResourceEventHandler&#123;</span><br><span class="line">      <span class="comment">// 定义过滤函数：必须为未调度的pod</span></span><br><span class="line">FilterFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> t := obj.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *v1.Pod:</span><br><span class="line"><span class="keyword">return</span> !assignedPod(t) &amp;&amp; responsibleForPod(t, sched.Profiles)</span><br><span class="line"><span class="keyword">case</span> cache.DeletedFinalStateUnknown:</span><br><span class="line"><span class="keyword">if</span> pod, ok := t.Obj.(*v1.Pod); ok &#123;</span><br><span class="line"><span class="keyword">return</span> !assignedPod(pod) &amp;&amp; responsibleForPod(pod, sched.Profiles)</span><br><span class="line">&#125;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;unable to convert object %T to *v1.Pod in %T&quot;</span>, obj, sched))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;unable to handle object in %T: %T&quot;</span>, sched, obj))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">     <span class="comment">// 增改删三个操作对应的Handler，操作到对应的Queue</span></span><br><span class="line">Handler: cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc:    sched.addPodToSchedulingQueue,</span><br><span class="line">UpdateFunc: sched.updatePodInSchedulingQueue,</span><br><span class="line">DeleteFunc: sched.deletePodFromSchedulingQueue,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 牢记我们第一阶段要分析的对象：create nginx pod，所以进入这个add的操作，对应加入到队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">addPodToSchedulingQueue</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">pod := obj.(*v1.Pod)</span><br><span class="line">klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;add event for unscheduled pod %s/%s&quot;</span>, pod.Namespace, pod.Name)</span><br><span class="line">  <span class="comment">// 加入到队列</span></span><br><span class="line"><span class="keyword">if</span> err := sched.SchedulingQueue.Add(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;unable to queue %T: %v&quot;</span>, obj, err))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队操作我们清楚了，那出队呢？我们回过头去看看上面定义的NextPod的方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeNextPodFunc</span><span class="params">(queue SchedulingQueue)</span> <span class="title">func</span><span class="params">()</span> *<span class="title">framework</span>.<span class="title">QueuedPodInfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">framework</span>.<span class="title">QueuedPodInfo</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从队列中弹出</span></span><br><span class="line">podInfo, err := queue.Pop()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;About to try and schedule pod %v/%v&quot;</span>, podInfo.Pod.Namespace, podInfo.Pod.Name)</span><br><span class="line"><span class="keyword">return</span> podInfo</span><br><span class="line">&#125;</span><br><span class="line">klog.Errorf(<span class="string">&quot;Error while retrieving next pod from scheduling queue: %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="scheduleOne"><a href="#scheduleOne" class="headerlink" title="scheduleOne"></a>scheduleOne</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 了解入队和出队操作后，我们看一下Scheduler运行的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !cache.WaitForCacheSync(ctx.Done(), sched.scheduledPodsHasSynced) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sched.SchedulingQueue.Run()</span><br><span class="line">  <span class="comment">// 调度一个pod对象</span></span><br><span class="line">wait.UntilWithContext(ctx, sched.scheduleOne, <span class="number">0</span>)</span><br><span class="line">sched.SchedulingQueue.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来scheduleOne方法代码很长，我们一步一步来看</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">scheduleOne</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// podInfo 就是从队列中获取到的pod对象</span></span><br><span class="line">podInfo := sched.NextPod()</span><br><span class="line"><span class="comment">// 检查pod的有效性</span></span><br><span class="line"><span class="keyword">if</span> podInfo == <span class="literal">nil</span> || podInfo.Pod == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pod := podInfo.Pod</span><br><span class="line">  <span class="comment">// 根据定义的 pod.Spec.SchedulerName 查到对应的profile</span></span><br><span class="line">prof, err := sched.profileForPod(pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Error(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 可以跳过调度的情况，一般pod进不来</span></span><br><span class="line"><span class="keyword">if</span> sched.skipPodSchedule(prof, pod) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用调度算法，获取结果</span></span><br><span class="line">scheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, prof, state, pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">出现调度失败的情况：</span></span><br><span class="line"><span class="comment">这个时候可能会触发抢占preempt，抢占是一套复杂的逻辑，后面我们专门会讲</span></span><br><span class="line"><span class="comment">目前假设各类资源充足，能正常调度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInSeconds(start))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// assumePod 是假设这个Pod按照前面的调度算法分配后，进行验证</span></span><br><span class="line">assumedPodInfo := podInfo.DeepCopy()</span><br><span class="line">assumedPod := assumedPodInfo.Pod</span><br><span class="line"><span class="comment">// SuggestedHost 为建议的分配的Host</span></span><br><span class="line">err = sched.assume(assumedPod, scheduleResult.SuggestedHost)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 失败就重新分配，不考虑这种情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行相关插件的代码先跳过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步绑定pod</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 有一系列的检查工作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正做绑定的动作</span></span><br><span class="line">err := sched.bind(bindingCycleCtx, prof, assumedPod, scheduleResult.SuggestedHost, state)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 错误处理，清除状态并重试</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 打印结果，调试时将log level调整到2以上</span></span><br><span class="line"><span class="keyword">if</span> klog.V(<span class="number">2</span>).Enabled() &#123;</span><br><span class="line">klog.InfoS(<span class="string">&quot;Successfully bound pod to node&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;node&quot;</span>, scheduleResult.SuggestedHost, <span class="string">&quot;evaluatedNodes&quot;</span>, scheduleResult.EvaluatedNodes, <span class="string">&quot;feasibleNodes&quot;</span>, scheduleResult.FeasibleNodes)</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// metrics中记录相关的监控指标</span></span><br><span class="line">metrics.PodScheduled(prof.Name, metrics.SinceInSeconds(start))</span><br><span class="line">metrics.PodSchedulingAttempts.Observe(<span class="keyword">float64</span>(podInfo.Attempts))</span><br><span class="line">      metrics.PodSchedulingDuration.WithLabelValues(getAttemptsLabel(podInfo)).Observe(metrics.SinceInSeconds(podInfo.InitialAttemptTimestamp))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行绑定后的插件</span></span><br><span class="line">prof.RunPostBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ScheduleResult"><a href="#ScheduleResult" class="headerlink" title="ScheduleResult"></a>ScheduleResult</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用算法下的Schedule</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">  scheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, prof, state, pod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">create</span><span class="params">()</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">  algo := core.NewGenericScheduler(</span><br><span class="line">c.schedulerCache,</span><br><span class="line">c.nodeInfoSnapshot,</span><br><span class="line">extenders,</span><br><span class="line">c.informerFactory.Core().V1().PersistentVolumeClaims().Lister(),</span><br><span class="line">c.disablePreemption,</span><br><span class="line">c.percentageOfNodesToScore,</span><br><span class="line">)</span><br><span class="line">  <span class="keyword">return</span> &amp;Scheduler&#123;</span><br><span class="line">Algorithm:       algo,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// genericScheduler 的 Schedule 的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">Schedule</span><span class="params">(ctx context.Context, prof *profile.Profile, state *framework.CycleState, pod *v1.Pod)</span> <span class="params">(result ScheduleResult, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 对 pod 进行 pvc 的信息检查</span></span><br><span class="line"><span class="keyword">if</span> err := podPassesBasicChecks(pod, g.pvcLister); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对当前的信息做一个快照</span></span><br><span class="line"><span class="keyword">if</span> err := g.snapshot(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Node 节点数量为0，表示无可用节点</span></span><br><span class="line"><span class="keyword">if</span> g.nodeInfoSnapshot.NumNodes() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result, ErrNoNodesAvailable</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// Predict阶段：找到所有满足调度条件的节点feasibleNodes，不满足的就直接过滤</span></span><br><span class="line">feasibleNodes, filteredNodesStatuses, err := g.findNodesThatFitPod(ctx, prof, state, pod)</span><br><span class="line"><span class="comment">// 没有可用节点直接报错</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(feasibleNodes) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result, &amp;FitError&#123;</span><br><span class="line">Pod:                   pod,</span><br><span class="line">NumAllNodes:           g.nodeInfoSnapshot.NumNodes(),</span><br><span class="line">FilteredNodesStatuses: filteredNodesStatuses,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有一个节点就直接选用</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(feasibleNodes) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ScheduleResult&#123;</span><br><span class="line">SuggestedHost:  feasibleNodes[<span class="number">0</span>].Name,</span><br><span class="line">EvaluatedNodes: <span class="number">1</span> + <span class="built_in">len</span>(filteredNodesStatuses),</span><br><span class="line">FeasibleNodes:  <span class="number">1</span>,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Priority阶段：通过打分，找到一个分数最高、也就是最优的节点</span></span><br><span class="line">priorityList, err := g.prioritizeNodes(ctx, prof, state, pod, feasibleNodes)</span><br><span class="line">host, err := g.selectHost(priorityList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ScheduleResult&#123;</span><br><span class="line">SuggestedHost:  host,</span><br><span class="line">EvaluatedNodes: <span class="built_in">len</span>(feasibleNodes) + <span class="built_in">len</span>(filteredNodesStatuses),</span><br><span class="line">FeasibleNodes:  <span class="built_in">len</span>(feasibleNodes),</span><br><span class="line">&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Predict 和 Priority 是选择调度节点的两个关键性步骤， 它的底层调用了各种algorithm算法。我们暂时不细看。</span></span><br><span class="line"><span class="comment">以我们前面讲到过的 NodeName 算法为例，节点必须与 NodeName 匹配，它是属于Predict阶段的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Assume"><a href="#Assume" class="headerlink" title="Assume"></a>Assume</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">assume</span><span class="params">(assumed *v1.Pod, host <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 将 host 填入到 pod spec字段的nodename，假定分配到对应的节点上</span></span><br><span class="line">assumed.Spec.NodeName = host</span><br><span class="line">  <span class="comment">// 调用 SchedulerCache 下的 AssumePod</span></span><br><span class="line"><span class="keyword">if</span> err := sched.SchedulerCache.AssumePod(assumed); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">&quot;scheduler cache AssumePod failed: %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sched.SchedulingQueue != <span class="literal">nil</span> &#123;</span><br><span class="line">sched.SchedulingQueue.DeleteNominatedPodIfExists(assumed)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回头去找 SchedulerCache 初始化的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">create</span><span class="params">()</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Scheduler&#123;</span><br><span class="line">SchedulerCache:  c.schedulerCache,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里就是初始化的实例 schedulerCache</span></span><br><span class="line">schedulerCache := internalcache.New(<span class="number">30</span>*time.Second, stopEverything)</span><br><span class="line">configurator := &amp;Configurator&#123;</span><br><span class="line">schedulerCache:           schedulerCache,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看AssumePod做了什么</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">AssumePod</span><span class="params">(pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取 pod 的 uid</span></span><br><span class="line">key, err := framework.GetPodKey(pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁操作，保证并发情况下的一致性</span></span><br><span class="line">cache.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> cache.mu.Unlock()</span><br><span class="line">  <span class="comment">// 根据 uid 找不到 pod 当前的状态</span></span><br><span class="line"><span class="keyword">if</span> _, ok := cache.podStates[key]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;pod %v is in the cache, so can&#x27;t be assumed&quot;</span>, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 Assume Pod 的信息放到对应 Node 节点中</span></span><br><span class="line">cache.addPod(pod)</span><br><span class="line">  <span class="comment">// 把 pod 状态设置为 Assume 成功</span></span><br><span class="line">ps := &amp;podState&#123;</span><br><span class="line">pod: pod,</span><br><span class="line">&#125;</span><br><span class="line">cache.podStates[key] = ps</span><br><span class="line">cache.assumedPods[key] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">bind</span><span class="params">(ctx context.Context, prof *profile.Profile, assumed *v1.Pod, targetNode <span class="keyword">string</span>, state *framework.CycleState)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">  <span class="comment">// 把 assumed 的 pod 信息保存下来</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">sched.finishBinding(prof, assumed, targetNode, start, err)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 阶段1： 运行扩展绑定进行验证，如果已经绑定报错</span></span><br><span class="line">bound, err := sched.extendersBinding(assumed, targetNode)</span><br><span class="line"><span class="keyword">if</span> bound &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 阶段2：运行绑定插件验证状态</span></span><br><span class="line">bindStatus := prof.RunBindPlugins(ctx, state, assumed, targetNode)</span><br><span class="line"><span class="keyword">if</span> bindStatus.IsSuccess() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> bindStatus.Code() == framework.Error &#123;</span><br><span class="line"><span class="keyword">return</span> bindStatus.AsError()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;bind status: %s, %v&quot;</span>, bindStatus.Code().String(), bindStatus.Message())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Update-To-Etcd"><a href="#Update-To-Etcd" class="headerlink" title="Update To Etcd"></a>Update To Etcd</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这块的代码我不做细致的逐层分析了，大家根据兴趣自行探索</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b DefaultBinder)</span> <span class="title">Bind</span><span class="params">(ctx context.Context, state *framework.CycleState, p *v1.Pod, nodeName <span class="keyword">string</span>)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;Attempting to bind %v/%v to %v&quot;</span>, p.Namespace, p.Name, nodeName)</span><br><span class="line">binding := &amp;v1.Binding&#123;</span><br><span class="line">ObjectMeta: metav1.ObjectMeta&#123;Namespace: p.Namespace, Name: p.Name, UID: p.UID&#125;,</span><br><span class="line">Target:     v1.ObjectReference&#123;Kind: <span class="string">&quot;Node&quot;</span>, Name: nodeName&#125;,</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// ClientSet就是访问kube-apiserver的客户端，将数据更新上去</span></span><br><span class="line">err := b.handle.ClientSet().CoreV1().Pods(binding.Namespace).Bind(ctx, binding, metav1.CreateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>今天这一次分享比较长，我们一起来总结一下：</p><ol><li>Pod的调度是通过一个队列<code>SchedulingQueue</code>异步工作的<ol><li>监听到对应pod事件后，放入队列</li><li>有个消费者从队列中获取pod，进行调度</li></ol></li><li>单个pod的调度主要分为3个步骤：<ol><li>根据Predict和Priority两个阶段，调用各自的算法插件，选择最优的Node</li><li>Assume这个Pod被调度到对应的Node，保存到cache</li><li>用extender和plugins进行验证，如果通过则绑定</li></ol></li><li>绑定成功后，将数据通过client向kube-apiserver发送，更新etcd</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚焦目标&quot;&gt;&lt;a href=&quot;#聚焦目标&quot; class=&quot;headerlink&quot; title=&quot;聚焦目标&quot;&gt;&lt;/a&gt;聚焦目标&lt;/h2&gt;&lt;p&gt;理解一个pod的被调度的大致流程 &lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【K8s源码品读】009：Phase 1 - kube-scheduler - Informer监听资源变化</title>
    <link href="http://example.com/2021/02/18/k8s-009/"/>
    <id>http://example.com/2021/02/18/k8s-009/</id>
    <published>2021-02-18T08:55:55.000Z</published>
    <updated>2021-02-18T09:00:07.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>了解<code>Informer</code>是如何从kube-apiserver监听资源变化的情况</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#informer">什么是Informer</a></li><li><a href="#Shared-Informer">Shared Informer的实现</a></li><li><a href="#PodInformer">PodInformer的背后的实现</a></li><li><a href="#Reflect">聚焦Reflect结构</a></li><li><a href="#Summary">本节小节</a></li></ol><h2 id="Informer"><a href="#Informer" class="headerlink" title="Informer"></a>Informer</h2><p>什么是<code>Informer</code>？这一节，我将先抛开代码，重点讲一下这个Informer，因为它是理解k8s运行机制的核心概念。</p><p>我没有在官方文档中找到<code>Informer</code>的明确定义，中文直译为<code>通知器</code>。从<a href="https://medium.com/@muhammet.arslan/write-your-own-kubernetes-controller-with-informers-9920e8ab6f84">这个链接</a>中，我们可以看到一个自定义资源的的处理流程。</p><p>我简单概况下，<code>Informer</code>的核心功能是 <strong>获取并监听(ListAndWatch)对应资源的增删改，触发相应的事件操作(ResourceEventHandler)</strong></p><h2 id="Shared-Informer"><a href="#Shared-Informer" class="headerlink" title="Shared Informer"></a>Shared Informer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">client 是连接到 kube-apiserver 的客户端。</span></span><br><span class="line"><span class="comment">我们要理解k8s的设计：</span></span><br><span class="line"><span class="comment">1. etcd是核心的数据存储，对资源的修改会进行持久化</span></span><br><span class="line"><span class="comment">2. 只有kube-apiserver可以访问etcd</span></span><br><span class="line"><span class="comment">所以，kube-scheduler要了解资源的变化情况，只能通过kube-apiserver</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了 Shared Informer，其中这个client是用来连接kube-apiserver的</span></span><br><span class="line">c.InformerFactory = informers.NewSharedInformerFactory(client, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里解答了为什么叫shared：一个资源会对应多个Informer，会导致效率低下，所以让一个资源对应一个sharedInformer，而一个sharedInformer内部自己维护多个Informer</span></span><br><span class="line"><span class="keyword">type</span> sharedInformerFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">client           kubernetes.Interface</span><br><span class="line">namespace        <span class="keyword">string</span></span><br><span class="line">tweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class="line">lock             sync.Mutex</span><br><span class="line">defaultResync    time.Duration</span><br><span class="line">customResync     <span class="keyword">map</span>[reflect.Type]time.Duration</span><br><span class="line">  <span class="comment">// 这个map就是维护多个Informer的关键实现</span></span><br><span class="line">informers <span class="keyword">map</span>[reflect.Type]cache.SharedIndexInformer</span><br><span class="line">startedInformers <span class="keyword">map</span>[reflect.Type]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">Start</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">f.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"><span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line"><span class="keyword">if</span> !f.startedInformers[informerType] &#123;</span><br><span class="line">      <span class="comment">// goroutine异步处理</span></span><br><span class="line"><span class="keyword">go</span> informer.Run(stopCh)</span><br><span class="line">      <span class="comment">// 标记为已经运行，这样即使下次Start也不会重复运行</span></span><br><span class="line">f.startedInformers[informerType] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找对应的informer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">InformerFor</span><span class="params">(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">f.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"><span class="comment">// 找到就直接返回</span></span><br><span class="line">informerType := reflect.TypeOf(obj)</span><br><span class="line">informer, exists := f.informers[informerType]</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line"><span class="keyword">return</span> informer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resyncPeriod, exists := f.customResync[informerType]</span><br><span class="line"><span class="keyword">if</span> !exists &#123;</span><br><span class="line">resyncPeriod = f.defaultResync</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没找到就会新建</span></span><br><span class="line">informer = newFunc(f.client, resyncPeriod)</span><br><span class="line">f.informers[informerType] = informer</span><br><span class="line"><span class="keyword">return</span> informer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SharedInformerFactory 是 sharedInformerFactory 的接口定义</span></span><br><span class="line"><span class="keyword">type</span> SharedInformerFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 我们这一阶段关注的Pod的Informer，属于核心资源</span></span><br><span class="line">Core() core.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// core.Interface的定义</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// V1 provides access to shared informers for resources in V1.</span></span><br><span class="line">V1() v1.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v1.Interface 的定义</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// Pod的定义</span></span><br><span class="line">Pods() PodInformer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PodInformer 是对应的接口</span></span><br><span class="line"><span class="keyword">type</span> PodInformer <span class="keyword">interface</span> &#123;</span><br><span class="line">Informer() cache.SharedIndexInformer</span><br><span class="line">Lister() v1.PodLister</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// podInformer 是具体的实现</span></span><br><span class="line"><span class="keyword">type</span> podInformer <span class="keyword">struct</span> &#123;</span><br><span class="line">factory          internalinterfaces.SharedInformerFactory</span><br><span class="line">tweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class="line">namespace        <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后，我们可以看到podInformer调用了InformerFor函数进行了添加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *podInformer)</span> <span class="title">Informer</span><span class="params">()</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> f.factory.InformerFor(&amp;corev1.Pod&#123;&#125;, f.defaultInformer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PodInformer"><a href="#PodInformer" class="headerlink" title="PodInformer"></a>PodInformer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化PodInformer，把对应的List/Watch操作方法传入到实例化函数，生成统一的SharedIndexInformer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFilteredPodInformer</span><span class="params">()</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cache.NewSharedIndexInformer(</span><br><span class="line">    <span class="comment">// List和Watch实现从PodInterface里面查询</span></span><br><span class="line">&amp;cache.ListWatch&#123;</span><br><span class="line">ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> tweakListOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">tweakListOptions(&amp;options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> client.CoreV1().Pods(namespace).List(context.TODO(), options)</span><br><span class="line">&#125;,</span><br><span class="line">WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> tweakListOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">tweakListOptions(&amp;options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> client.CoreV1().Pods(namespace).Watch(context.TODO(), options)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&amp;corev1.Pod&#123;&#125;,</span><br><span class="line">resyncPeriod,</span><br><span class="line">indexers,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们先看看Pod基本的List和Watch是怎么定义的</span></span><br><span class="line"><span class="comment">// Pod基本的增删改查等操作</span></span><br><span class="line"><span class="keyword">type</span> PodInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">List(ctx context.Context, opts metav1.ListOptions) (*v1.PodList, error)</span><br><span class="line">Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pods 是PodInterface的实现</span></span><br><span class="line"><span class="keyword">type</span> pods <span class="keyword">struct</span> &#123;</span><br><span class="line">client rest.Interface</span><br><span class="line">ns     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 和 Watch 是依赖客户端，也就是从kube-apiserver中查询的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pods)</span> <span class="title">List</span><span class="params">(ctx context.Context, opts metav1.ListOptions)</span> <span class="params">(result *v1.PodList, err error)</span></span> &#123;</span><br><span class="line">err = c.client.Get().</span><br><span class="line">Namespace(c.ns).</span><br><span class="line">Resource(<span class="string">&quot;pods&quot;</span>).</span><br><span class="line">VersionedParams(&amp;opts, scheme.ParameterCodec).</span><br><span class="line">Timeout(timeout).</span><br><span class="line">Do(ctx).</span><br><span class="line">Into(result)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pods)</span> <span class="title">Watch</span><span class="params">(ctx context.Context, opts metav1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.client.Get().</span><br><span class="line">Namespace(c.ns).</span><br><span class="line">Resource(<span class="string">&quot;pods&quot;</span>).</span><br><span class="line">VersionedParams(&amp;opts, scheme.ParameterCodec).</span><br><span class="line">Timeout(timeout).</span><br><span class="line">Watch(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上面，我们看到了异步运行Informer的代码 go informer.Run(stopCh)，我们看看是怎么run的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里有个 DeltaFIFO 的对象，</span></span><br><span class="line">  fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions&#123;</span><br><span class="line">KnownObjects:          s.indexer,</span><br><span class="line">EmitDeltaTypeReplaced: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 传入这个fifo到cfg</span></span><br><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">Queue:            fifo,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新建controller</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">s.startedLock.Lock()</span><br><span class="line"><span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">s.controller = New(cfg)</span><br><span class="line">s.controller.(*controller).clock = s.clock</span><br><span class="line">s.started = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 运行controller</span></span><br><span class="line">s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Controller的运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">r := NewReflector(</span><br><span class="line">c.config.ListerWatcher,</span><br><span class="line">c.config.ObjectType,</span><br><span class="line">c.config.Queue,</span><br><span class="line">c.config.FullResyncPeriod,</span><br><span class="line">)</span><br><span class="line">r.ShouldResync = c.config.ShouldResync</span><br><span class="line">r.clock = c.clock</span><br><span class="line"><span class="keyword">if</span> c.config.WatchErrorHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">r.watchErrorHandler = c.config.WatchErrorHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.reflectorMutex.Lock()</span><br><span class="line">c.reflector = r</span><br><span class="line">c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg wait.Group</span><br><span class="line">  <span class="comment">// 生产，往Queue里放数据</span></span><br><span class="line">wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line">  <span class="comment">// 消费，从Queue消费数据</span></span><br><span class="line">wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们再回头看看这个Reflect结构</span></span><br><span class="line">r := NewReflector(</span><br><span class="line">  <span class="comment">// ListerWatcher 我们已经有了解，就是通过client监听kube-apiserver暴露出来的Resource</span></span><br><span class="line">c.config.ListerWatcher,</span><br><span class="line">c.config.ObjectType,</span><br><span class="line">  <span class="comment">// Queue 是我们前文看到的一个 DeltaFIFOQueue，认为这是一个先进先出的队列</span></span><br><span class="line">c.config.Queue,</span><br><span class="line">c.config.FullResyncPeriod,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;Starting reflector %s (%s) from %s&quot;</span>, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class="line">wait.BackoffUntil(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用了ListAndWatch</span></span><br><span class="line"><span class="keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">r.watchErrorHandler(r, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, r.backoffManager, <span class="literal">true</span>, stopCh)</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;Stopping reflector %s (%s) from %s&quot;</span>, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// watchHandler顾名思义，就是Watch到对应的事件，调用对应的Handler</span></span><br><span class="line"><span class="keyword">if</span> err := r.watchHandler(start, w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != errorStopRequested &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> isExpiredError(err):</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;%s: watch of %v closed with: %v&quot;</span>, r.name, r.expectedTypeName, err)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">klog.Warningf(<span class="string">&quot;%s: watch of %v ended with: %v&quot;</span>, r.name, r.expectedTypeName, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">watchHandler</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">loop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 一个经典的GO语言select监听多channel的模式</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 整体的step channel</span></span><br><span class="line"><span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line"><span class="keyword">return</span> errorStopRequested</span><br><span class="line">    <span class="comment">// 错误相关的error channel</span></span><br><span class="line"><span class="keyword">case</span> err := &lt;-errc:</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">    <span class="comment">// 接收事件event的channel</span></span><br><span class="line"><span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">      <span class="comment">// channel被关闭，退出loop</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span> loop</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 一系列的资源验证代码跳过</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">      <span class="comment">// 增删改三种Event，分别对应到去store，即DeltaFIFO中，操作object</span></span><br><span class="line"><span class="keyword">case</span> watch.Added:</span><br><span class="line">err := r.store.Add(event.Object)</span><br><span class="line"><span class="keyword">case</span> watch.Modified:</span><br><span class="line">err := r.store.Update(event.Object)</span><br><span class="line"><span class="keyword">case</span> watch.Deleted:</span><br><span class="line">err := r.store.Delete(event.Object)</span><br><span class="line"><span class="keyword">case</span> watch.Bookmark:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;%s: unable to understand watch event %#v&quot;</span>, r.name, event))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol><li><code>Informer</code> 依赖于 <code>Reflector</code> 模块，它有个组件为 xxxInformer，如 <code>podInformer</code> </li><li>具体资源的 <code>Informer</code> 包含了一个连接到<code>kube-apiserver</code>的<code>client</code>，通过<code>List</code>和<code>Watch</code>接口查询资源变更情况</li><li>检测到资源发生变化后，通过<code>Controller</code> 将数据放入队列<code>DeltaFIFOQueue</code>里，生产阶段完成</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚焦目标&quot;&gt;&lt;a href=&quot;#聚焦目标&quot; class=&quot;headerlink&quot; title=&quot;聚焦目标&quot;&gt;&lt;/a&gt;聚焦目标&lt;/h2&gt;&lt;p&gt;了解&lt;code&gt;Informer&lt;/code&gt;是如何从kube-apiserver监听资源变化的情况&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【K8s源码品读】010：Phase 1 - kube-scheduler - Informer是如何保存数据的</title>
    <link href="http://example.com/2021/02/18/k8s-010/"/>
    <id>http://example.com/2021/02/18/k8s-010/</id>
    <published>2021-02-18T08:55:55.000Z</published>
    <updated>2021-02-18T09:00:19.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>了解Informer在发现资源变化后，是怎么处理的</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol start="5"><li><a href="#Process">查看消费的过程</a></li><li><a href="#Index">掌握Index数据结构</a></li><li><a href="#distribute">信息的分发distribute</a></li><li><a href="#Summary">Informer的综合思考</a></li></ol><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// Pop出Object元素</span></span><br><span class="line">obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == ErrFIFOClosed &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line"><span class="comment">// 重新进队列</span></span><br><span class="line">c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去查看Pop的具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">f.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 调用process去处理item，然后返回</span></span><br><span class="line">item, ok := f.items[id]</span><br><span class="line"><span class="built_in">delete</span>(f.items, id)</span><br><span class="line">err := process(item)</span><br><span class="line"><span class="keyword">return</span> item, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后去查一下 PopProcessFunc 的定义，在创建controller前</span></span><br><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">Process:           s.HandleDeltas,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HandleDeltas</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">s.blockDeltas.Lock()</span><br><span class="line"><span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line"><span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">    <span class="comment">// 增、改、替换、同步</span></span><br><span class="line"><span class="keyword">case</span> Sync, Replaced, Added, Updated:</span><br><span class="line">s.cacheMutationDetector.AddObject(d.Object)</span><br><span class="line">      <span class="comment">// 先去indexer查询</span></span><br><span class="line"><span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">        <span class="comment">// 如果数据已经存在，就执行Update逻辑</span></span><br><span class="line"><span class="keyword">if</span> err := s.indexer.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isSync := <span class="literal">false</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> d.Type == Sync:</span><br><span class="line">isSync = <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> d.Type == Replaced:</span><br><span class="line"><span class="keyword">if</span> accessor, err := meta.Accessor(d.Object); err == <span class="literal">nil</span> &#123;</span><br><span class="line">isSync = accessor.GetResourceVersion() == oldAccessor.GetResourceVersion()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 分发Update事件</span></span><br><span class="line">s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没查到数据，就执行Add操作</span></span><br><span class="line"><span class="keyword">if</span> err := s.indexer.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 分发 Add 事件</span></span><br><span class="line">s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">case</span> Deleted:</span><br><span class="line">    <span class="comment">// 去indexer删除</span></span><br><span class="line"><span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 分发 delete 事件</span></span><br><span class="line">s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p><code>Index</code> 的定义为资源的本地存储，保持与etcd中的资源信息一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们去看看Index是怎么创建的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSharedIndexInformer</span><span class="params">(lw ListerWatcher, exampleObject runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers)</span> <span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">realClock := &amp;clock.RealClock&#123;&#125;</span><br><span class="line">sharedIndexInformer := &amp;sharedIndexInformer&#123;</span><br><span class="line">processor:                       &amp;sharedProcessor&#123;clock: realClock&#125;,</span><br><span class="line">    <span class="comment">// indexer 的初始化</span></span><br><span class="line">indexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),</span><br><span class="line">listerWatcher:                   lw,</span><br><span class="line">objectType:                      exampleObject,</span><br><span class="line">resyncCheckPeriod:               defaultEventHandlerResyncPeriod,</span><br><span class="line">defaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,</span><br><span class="line">cacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf(<span class="string">&quot;%T&quot;</span>, exampleObject)),</span><br><span class="line">clock:                           realClock,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sharedIndexInformer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个map和func组合而成的Indexer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIndexer</span><span class="params">(keyFunc KeyFunc, indexers Indexers)</span> <span class="title">Indexer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;cache&#123;</span><br><span class="line">cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),</span><br><span class="line">keyFunc:      keyFunc,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadSafeStore的底层是一个并发安全的map，具体实现我们暂不考虑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewThreadSafeStore</span><span class="params">(indexers Indexers, indices Indices)</span> <span class="title">ThreadSafeStore</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;threadSafeMap&#123;</span><br><span class="line">items:    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">indexers: indexers,</span><br><span class="line">indices:  indices,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="distribute"><a href="#distribute" class="headerlink" title="distribute"></a>distribute</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在上面的Process代码中，我们看到了将数据存储到Indexer后，调用了一个分发的函数</span></span><br><span class="line">s.processor.distribute()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分发process的创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSharedIndexInformer</span><span class="params">()</span> <span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">sharedIndexInformer := &amp;sharedIndexInformer&#123;</span><br><span class="line">processor:                       &amp;sharedProcessor&#123;clock: realClock&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sharedIndexInformer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sharedProcessor的结构</span></span><br><span class="line"><span class="keyword">type</span> sharedProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">listenersStarted <span class="keyword">bool</span></span><br><span class="line"> <span class="comment">// 读写锁</span></span><br><span class="line">listenersLock    sync.RWMutex</span><br><span class="line">  <span class="comment">// 普通监听列表</span></span><br><span class="line">listeners        []*processorListener</span><br><span class="line">  <span class="comment">// 同步监听列表</span></span><br><span class="line">syncingListeners []*processorListener</span><br><span class="line">clock            clock.Clock</span><br><span class="line">wg               wait.Group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看distribute函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">distribute</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, sync <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p.listenersLock.RLock()</span><br><span class="line"><span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line"><span class="comment">// 将object分发到 同步监听 或者 普通监听 的列表</span></span><br><span class="line"><span class="keyword">if</span> sync &#123;</span><br><span class="line"><span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.syncingListeners &#123;</span><br><span class="line">listener.add(obj)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">listener.add(obj)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个add的操作是利用了channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">add</span><span class="params">(notification <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">p.addCh &lt;- notification</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol><li><code>Informer</code> 依赖于 <code>Reflector</code> 模块，它有个组件为 xxxInformer，如 <code>podInformer</code> </li><li>具体资源的 <code>Informer</code> 包含了一个连接到<code>kube-apiserver</code>的<code>client</code>，通过<code>List</code>和<code>Watch</code>接口查询资源变更情况</li><li>检测到资源发生变化后，通过<code>Controller</code> 将数据放入队列<code>DeltaFIFOQueue</code>里，生产阶段完成</li><li>在<code>DeltaFIFOQueue</code>的另一端，有消费者在不停地处理资源变化的事件，处理逻辑主要分2步<ol><li>将数据保存到本地存储Indexer，它的底层实现是一个并发安全的threadSafeMap</li><li>有些组件需要实时关注资源变化，会实时监听listen，就将事件分发到对应注册上来的listener上，自行处理</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚焦目标&quot;&gt;&lt;a href=&quot;#聚焦目标&quot; class=&quot;headerlink&quot; title=&quot;聚焦目标&quot;&gt;&lt;/a&gt;聚焦目标&lt;/h2&gt;&lt;p&gt;了解Informer在发现资源变化后，是怎么处理的&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【K8s源码品读】008：Phase 1 - kube-scheduler - 初探调度的启动流程与算法</title>
    <link href="http://example.com/2021/02/18/k8s-008/"/>
    <id>http://example.com/2021/02/18/k8s-008/</id>
    <published>2021-02-18T08:55:54.000Z</published>
    <updated>2021-02-18T08:59:53.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解kube-scheduler启动的流程</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#run">kube-scheduler的启动</a></li><li><a href="#Scheduler">Scheduler的注册</a></li><li><a href="#NodeName">了解一个最简单的算法NodeName</a></li></ol><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kube-scheduler 类似于kube-apiserver，是个常驻进程，查看其对应的Run函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCommand</span><span class="params">(cmd *cobra.Command, opts *options.Options, registryOptions ...Option)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 根据入参，返回配置cc与调度sched</span></span><br><span class="line">   cc, sched, err := Setup(ctx, opts, registryOptions...)</span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line">   <span class="keyword">return</span> Run(ctx, cc, sched)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行调度策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(ctx context.Context, cc *schedulerserverconfig.CompletedConfig, sched *scheduler.Scheduler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 将配置注册到configz中，会保存在一个全局map里</span></span><br><span class="line"><span class="keyword">if</span> cz, err := configz.New(<span class="string">&quot;componentconfig&quot;</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">cz.Set(cc.ComponentConfig)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to register configz: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件广播管理器，涉及到k8s里的一个核心资源 - Event事件，暂时不细讲</span></span><br><span class="line">cc.EventBroadcaster.StartRecordingToSink(ctx.Done())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 健康监测的服务</span></span><br><span class="line"><span class="keyword">var</span> checks []healthz.HealthChecker</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步各个Informer。Informer是kube-scheduler的一个重点</span></span><br><span class="line"><span class="keyword">go</span> cc.PodInformer.Informer().Run(ctx.Done())</span><br><span class="line">cc.InformerFactory.Start(ctx.Done())</span><br><span class="line">cc.InformerFactory.WaitForCacheSync(ctx.Done())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选举Leader的工作，因为Master节点可以存在多个，选举一个作为Leader</span></span><br><span class="line"><span class="keyword">if</span> cc.LeaderElection != <span class="literal">nil</span> &#123;</span><br><span class="line">cc.LeaderElection.Callbacks = leaderelection.LeaderCallbacks&#123;</span><br><span class="line">      <span class="comment">// 两个钩子函数，开启Leading时运行调度，结束时打印报错</span></span><br><span class="line">OnStartedLeading: sched.Run,</span><br><span class="line">OnStoppedLeading: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">&quot;leaderelection lost&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">leaderElector, err := leaderelection.NewLeaderElector(*cc.LeaderElection)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;couldn&#x27;t create leader elector: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 参与选举的会持续通信</span></span><br><span class="line">leaderElector.Run(ctx)</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;lost lease&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不参与选举的，也就是单节点的情况时，在这里运行</span></span><br><span class="line">sched.Run(ctx)</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;finished without leader elect&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">到这里，我们已经接触了kube-scheduler的2个核心概念：</span></span><br><span class="line"><span class="comment">1. scheduler：正如程序名kube-scheduler，这个进程的核心作用是进行调度，会涉及到多种调度策略</span></span><br><span class="line"><span class="comment">2. Informer：k8s中有各种类型的资源，包括自定义的。而Informer的实现就将调度和资源结合了起来</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在创建scheduler的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Setup</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建scheduler，包括多个选项</span></span><br><span class="line">sched, err := scheduler.New(cc.Client,</span><br><span class="line">cc.InformerFactory,</span><br><span class="line">cc.PodInformer,</span><br><span class="line">recorderFactory,</span><br><span class="line">ctx.Done(),</span><br><span class="line">scheduler.WithProfiles(cc.ComponentConfig.Profiles...),</span><br><span class="line">scheduler.WithAlgorithmSource(cc.ComponentConfig.AlgorithmSource),</span><br><span class="line">scheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),</span><br><span class="line">scheduler.WithFrameworkOutOfTreeRegistry(outOfTreeRegistry),</span><br><span class="line">scheduler.WithPodMaxBackoffSeconds(cc.ComponentConfig.PodMaxBackoffSeconds),</span><br><span class="line">scheduler.WithPodInitialBackoffSeconds(cc.ComponentConfig.PodInitialBackoffSeconds),</span><br><span class="line">scheduler.WithExtenders(cc.ComponentConfig.Extenders...),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> &amp;cc, sched, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再看一下New这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 先注册了所有的算法，保存到一个 map[string]PluginFactory 中</span></span><br><span class="line">  registry := frameworkplugins.NewInTreeRegistry()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重点看一下Scheduler的创建过程</span></span><br><span class="line">  <span class="keyword">var</span> sched *Scheduler</span><br><span class="line">source := options.schedulerAlgorithmSource</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">   <span class="comment">// 根据Provider创建，重点看这里</span></span><br><span class="line"><span class="keyword">case</span> source.Provider != <span class="literal">nil</span>:</span><br><span class="line">sc, err := configurator.createFromProvider(*source.Provider)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;couldn&#x27;t create scheduler using provider %q: %v&quot;</span>, *source.Provider, err)</span><br><span class="line">&#125;</span><br><span class="line">sched = sc</span><br><span class="line">  <span class="comment">// 根据用户设置创建，来自文件或者ConfigMap</span></span><br><span class="line"><span class="keyword">case</span> source.Policy != <span class="literal">nil</span>:</span><br><span class="line">policy := &amp;schedulerapi.Policy&#123;&#125;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> source.Policy.File != <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">if</span> err := initPolicyFromFile(source.Policy.File.Path, policy); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> source.Policy.ConfigMap != <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">if</span> err := initPolicyFromConfigMap(client, source.Policy.ConfigMap, policy); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">configurator.extenders = policy.Extenders</span><br><span class="line">sc, err := configurator.createFromConfig(*policy)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;couldn&#x27;t create scheduler from policy: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">sched = sc</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unsupported algorithm source: %v&quot;</span>, source)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">createFromProvider</span><span class="params">(providerName <span class="keyword">string</span>)</span> <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;Creating scheduler from algorithm provider &#x27;%v&#x27;&quot;</span>, providerName)</span><br><span class="line">  <span class="comment">// 实例化算法的Registry</span></span><br><span class="line">r := algorithmprovider.NewRegistry()</span><br><span class="line">defaultPlugins, exist := r[providerName]</span><br><span class="line"><span class="keyword">if</span> !exist &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;algorithm provider %q is not registered&quot;</span>, providerName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将各种算法作为plugin进行设置</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.profiles &#123;</span><br><span class="line">prof := &amp;c.profiles[i]</span><br><span class="line">plugins := &amp;schedulerapi.Plugins&#123;&#125;</span><br><span class="line">plugins.Append(defaultPlugins)</span><br><span class="line">plugins.Apply(prof.Plugins)</span><br><span class="line">prof.Plugins = plugins</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.create()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这个初始化中可以看到，主要分为2类：默认与ClusterAutoscaler两种算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRegistry</span><span class="params">()</span> <span class="title">Registry</span></span> &#123;</span><br><span class="line">  <span class="comment">// 默认算法包括过滤、打分、绑定等，有兴趣的去源码中逐个阅读</span></span><br><span class="line">defaultConfig := getDefaultConfig()</span><br><span class="line">applyFeatureGates(defaultConfig)</span><br><span class="line"><span class="comment">// ClusterAutoscaler 是集群自动扩展的算法，被单独拎出来，</span></span><br><span class="line">caConfig := getClusterAutoscalerConfig()</span><br><span class="line">applyFeatureGates(caConfig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Registry&#123;</span><br><span class="line">schedulerapi.SchedulerDefaultProviderName: defaultConfig,</span><br><span class="line">ClusterAutoscalerProvider:                 caConfig,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在这里，熟悉k8s的朋友会有个疑问：以前听说kubernets的调度有个Predicate和Priority两个算法，这里怎么没有分类？</span></span><br><span class="line"><span class="comment">这个疑问，我们在后面具体场景时再进行分析。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="NodeName"><a href="#NodeName" class="headerlink" title="NodeName"></a>NodeName</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了加深大家对Plugin的印象，我选择一个最简单的示例：根据Pod的spec字段中的NodeName，分配到指定名称的节点</span></span><br><span class="line"><span class="keyword">package</span> nodename</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line">v1 <span class="string">&quot;k8s.io/api/core/v1&quot;</span></span><br><span class="line"><span class="string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span></span><br><span class="line">framework <span class="string">&quot;k8s.io/kubernetes/pkg/scheduler/framework/v1alpha1&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NodeName <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ framework.FilterPlugin = &amp;NodeName&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个调度算法的名称和错误信息</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Name = <span class="string">&quot;NodeName&quot;</span></span><br><span class="line">ErrReason = <span class="string">&quot;node(s) didn&#x27;t match the requested hostname&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度算法的明明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeName)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤功能，这个就是NodeName算法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeName)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">  <span class="comment">// 找不到Node</span></span><br><span class="line"><span class="keyword">if</span> nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">&quot;node not found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 匹配不到，返回错误</span></span><br><span class="line"><span class="keyword">if</span> !Fits(pod, nodeInfo) &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReason)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  匹配的算法，两种条件满足一个就认为成功</span></span><br><span class="line"><span class="comment">  1. spec没有填NodeName </span></span><br><span class="line"><span class="comment">  2.spec的NodeName和节点匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fits</span><span class="params">(pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(pod.Spec.NodeName) == <span class="number">0</span> || pod.Spec.NodeName == nodeInfo.Node().Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(_ runtime.Object, _ framework.FrameworkHandle)</span> <span class="params">(framework.Plugin, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;NodeName&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚焦目标&quot;&gt;&lt;a href=&quot;#聚焦目标&quot; class=&quot;headerlink&quot; title=&quot;聚焦目标&quot;&gt;&lt;/a&gt;聚焦目标&lt;/h2&gt;&lt;p&gt;理解kube-scheduler启动的流程&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;hea
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【K8s源码品读】007：Phase 1 - kube-apiserver - Pod数据的保存</title>
    <link href="http://example.com/2021/02/18/k8s-007/"/>
    <id>http://example.com/2021/02/18/k8s-007/</id>
    <published>2021-02-18T08:55:53.000Z</published>
    <updated>2021-02-18T08:59:37.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解Pod发送到<code>kube-apiserver</code>后是怎么保存的</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#RESTCreateStrategy">RESTCreateStrategy创建的预处理</a></li><li><a href="#Storage">REST Pod数据的存储</a></li><li><a href="#storage-implement">存储的底层实现</a></li><li><a href="#summary">kube-apiserver第一阶段源码阅读总结</a></li></ol><h2 id="RESTCreateStrategy"><a href="#RESTCreateStrategy" class="headerlink" title="RESTCreateStrategy"></a>RESTCreateStrategy</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// podStrategy 是封装了 Pod 的各类动作，这里我们先关注create这个操作</span></span><br><span class="line"><span class="keyword">type</span> podStrategy <span class="keyword">struct</span> &#123;</span><br><span class="line">runtime.ObjectTyper</span><br><span class="line">names.NameGenerator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// podStrategy 的接口</span></span><br><span class="line"><span class="keyword">type</span> RESTCreateStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">runtime.ObjectTyper</span><br><span class="line">names.NameGenerator</span><br><span class="line">  <span class="comment">// 是否属于当前的 namespace</span></span><br><span class="line">NamespaceScoped() <span class="keyword">bool</span></span><br><span class="line">  <span class="comment">// 准备创建前的检查</span></span><br><span class="line">PrepareForCreate(ctx context.Context, obj runtime.Object)</span><br><span class="line">  <span class="comment">// 验证资源对象</span></span><br><span class="line">Validate(ctx context.Context, obj runtime.Object) field.ErrorList</span><br><span class="line">  <span class="comment">// 规范化</span></span><br><span class="line">Canonicalize(obj runtime.Object)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成了检查，我们就要保存数据了</span></span><br></pre></td></tr></table></figure><h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PodStorage 是 Pod 存储的实现，里面包含了多个存储的定义</span></span><br><span class="line"><span class="keyword">type</span> PodStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// REST implements a RESTStorage for pods</span></span><br><span class="line">Pod                 *REST</span><br><span class="line">  <span class="comment">// BindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.</span></span><br><span class="line">Binding             *BindingREST</span><br><span class="line">  <span class="comment">// LegacyBindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.</span></span><br><span class="line">LegacyBinding       *LegacyBindingREST</span><br><span class="line">Eviction            *EvictionREST</span><br><span class="line">  <span class="comment">// StatusREST implements the REST endpoint for changing the status of a pod.</span></span><br><span class="line">Status              *StatusREST</span><br><span class="line">  <span class="comment">// EphemeralContainersREST implements the REST endpoint for adding EphemeralContainers</span></span><br><span class="line">EphemeralContainers *EphemeralContainersREST</span><br><span class="line">Log                 *podrest.LogREST</span><br><span class="line">Proxy               *podrest.ProxyREST</span><br><span class="line">Exec                *podrest.ExecREST</span><br><span class="line">Attach              *podrest.AttachREST</span><br><span class="line">PortForward         *podrest.PortForwardREST</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从上一节的map关系中，保存在REST中</span></span><br><span class="line"><span class="comment">restStorageMap := map[string]rest.Storage&#123;</span></span><br><span class="line"><span class="comment">&quot;pods&quot;:             podStorage.Pod,</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> REST <span class="keyword">struct</span> &#123;</span><br><span class="line">*genericregistry.Store</span><br><span class="line">proxyTransport http.RoundTripper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store是一个通用的数据结构</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Storage定义</span></span><br><span class="line">Storage DryRunnableStorage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DryRunnableStorage中的Storage是一个Interface</span></span><br><span class="line"><span class="keyword">type</span> DryRunnableStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">Storage storage.Interface</span><br><span class="line">Codec   runtime.Codec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DryRunnableStorage)</span> <span class="title">Create</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, obj, out runtime.Object, ttl <span class="keyword">uint64</span>, dryRun <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> dryRun &#123;</span><br><span class="line"><span class="keyword">if</span> err := s.Storage.Get(ctx, key, storage.GetOptions&#123;&#125;, out); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> storage.NewKeyExistsError(key, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s.copyInto(obj, out)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 这里，就是Create的真正调用</span></span><br><span class="line"><span class="keyword">return</span> s.Storage.Create(ctx, key, obj, out, ttl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Storage-Implement"><a href="#Storage-Implement" class="headerlink" title="Storage Implement"></a>Storage Implement</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Storage Interface 的定义，包括基本的增删改查，以及watch等等进阶操作</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">Versioner() Versioner</span><br><span class="line">Create(ctx context.Context, key <span class="keyword">string</span>, obj, out runtime.Object, ttl <span class="keyword">uint64</span>) error</span><br><span class="line">Delete(ctx context.Context, key <span class="keyword">string</span>, out runtime.Object, preconditions *Preconditions, validateDeletion ValidateObjectFunc) error</span><br><span class="line">Watch(ctx context.Context, key <span class="keyword">string</span>, opts ListOptions) (watch.Interface, error)</span><br><span class="line">WatchList(ctx context.Context, key <span class="keyword">string</span>, opts ListOptions) (watch.Interface, error)</span><br><span class="line">Get(ctx context.Context, key <span class="keyword">string</span>, opts GetOptions, objPtr runtime.Object) error</span><br><span class="line">GetToList(ctx context.Context, key <span class="keyword">string</span>, opts ListOptions, listObj runtime.Object) error</span><br><span class="line">List(ctx context.Context, key <span class="keyword">string</span>, opts ListOptions, listObj runtime.Object) error</span><br><span class="line">GuaranteedUpdate(</span><br><span class="line">ctx context.Context, key <span class="keyword">string</span>, ptrToType runtime.Object, ignoreNotFound <span class="keyword">bool</span>,</span><br><span class="line">precondtions *Preconditions, tryUpdate UpdateFunc, suggestion ...runtime.Object) error</span><br><span class="line">Count(key <span class="keyword">string</span>) (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRawStorage</span><span class="params">(config *storagebackend.Config)</span> <span class="params">(storage.Interface, factory.DestroyFunc, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> factory.Create(*config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(c storagebackend.Config)</span> <span class="params">(storage.Interface, DestroyFunc, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> c.Type &#123;</span><br><span class="line">  <span class="comment">// 已经不支持etcd2</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;etcd2&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%v is no longer a supported storage backend&quot;</span>, c.Type)</span><br><span class="line">  <span class="comment">// 默认为etcd3版本</span></span><br><span class="line"><span class="keyword">case</span> storagebackend.StorageTypeUnset, storagebackend.StorageTypeETCD3:</span><br><span class="line"><span class="keyword">return</span> newETCD3Storage(c)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unknown storage type: %s&quot;</span>, c.Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>我们对第一阶段学习kube-apiserver的知识点进行总结：</p><ol><li><code>kube-apiserver</code> 包含三个apiserver<code>APIExtensionsServer</code>、<code>KubeAPIServer</code>和<code>AggregatorServer</code><ol><li>三个APIServer底层均依赖通用的<code>GenericServer</code>，使用<code>go-restful</code>对外提供RESTful风格的API服务</li></ol></li><li><code>kube-apiserver</code> 对请求进行 <code>Authentication</code>、<code>Authorization</code>和<code>Admission</code>三层验证</li><li>完成验证后，请求会根据路由规则，触发到对应资源的handler，主要包括数据的<code>预处理</code>和<code>保存</code></li><li><code>kube-apiserver</code> 的底层存储为etcd v3，它被抽象为一种RESTStorage，使请求和存储操作一一对应</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚焦目标&quot;&gt;&lt;a href=&quot;#聚焦目标&quot; class=&quot;headerlink&quot; title=&quot;聚焦目标&quot;&gt;&lt;/a&gt;聚焦目标&lt;/h2&gt;&lt;p&gt;理解Pod发送到&lt;code&gt;kube-apiserver&lt;/code&gt;后是怎么保存的&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【K8s源码品读】006：Phase 1 - kube-apiserver - GenericAPIServer的初始化</title>
    <link href="http://example.com/2021/02/18/k8s-006/"/>
    <id>http://example.com/2021/02/18/k8s-006/</id>
    <published>2021-02-18T08:55:52.000Z</published>
    <updated>2021-02-18T08:59:20.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解kube-apiserver是中的管理核心资源的<code>KubeAPIServer</code>是怎么启动的</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#genericServer">genericServer的创建</a></li><li><a href="#NewAPIServerHandler">创建REST的Handler</a></li><li><a href="#installAPI">Generic的API路由规则</a></li><li><a href="#apiserver">初始化核心Apiserver</a></li><li><a href="#InstallLegacyAPI">核心资源的API路由规则</a></li><li><a href="#create-pod">创建Pod的函数</a></li></ol><h2 id="GenericServer"><a href="#GenericServer" class="headerlink" title="GenericServer"></a>GenericServer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在APIExtensionsServer、KubeAPIServer和AggregatorServer三种Server启动时，我们都能发现这么一个函数</span></span><br><span class="line"><span class="comment">// APIExtensionsServer</span></span><br><span class="line">genericServer, err := c.GenericConfig.New(<span class="string">&quot;apiextensions-apiserver&quot;</span>, delegationTarget)</span><br><span class="line"><span class="comment">// KubeAPIServer</span></span><br><span class="line">s, err := c.GenericConfig.New(<span class="string">&quot;kube-apiserver&quot;</span>, delegationTarget)</span><br><span class="line"><span class="comment">// AggregatorServer</span></span><br><span class="line">genericServer, err := c.GenericConfig.New(<span class="string">&quot;kube-aggregator&quot;</span>, delegationTarget)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都通过GenericConfig创建了genericServer，我们先大致浏览下</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">New</span><span class="params">(name <span class="keyword">string</span>, delegationTarget DelegationTarget)</span> <span class="params">(*GenericAPIServer, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建Handler</span></span><br><span class="line">apiServerHandler := NewAPIServerHandler(name, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 实例化一个Server</span></span><br><span class="line">s := &amp;GenericAPIServer&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理钩子hook操作</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> delegationTarget.PostStartHooks() &#123;</span><br><span class="line">s.postStartHooks[k] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> delegationTarget.PreShutdownHooks() &#123;</span><br><span class="line">s.preShutdownHooks[k] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 健康监测</span></span><br><span class="line"><span class="keyword">for</span> _, delegateCheck := <span class="keyword">range</span> delegationTarget.HealthzChecks() &#123;</span><br><span class="line">skip := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, existingCheck := <span class="keyword">range</span> c.HealthzChecks &#123;</span><br><span class="line"><span class="keyword">if</span> existingCheck.Name() == delegateCheck.Name() &#123;</span><br><span class="line">skip = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> skip &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">s.AddHealthChecks(delegateCheck)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安装API相关参数，这个是重点</span></span><br><span class="line">installAPI(s, c.Config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NewAPIServerHandler"><a href="#NewAPIServerHandler" class="headerlink" title="NewAPIServerHandler"></a>NewAPIServerHandler</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAPIServerHandler</span><span class="params">(name <span class="keyword">string</span>, s runtime.NegotiatedSerializer, handlerChainBuilder HandlerChainBuilderFn, notFoundHandler http.Handler)</span> *<span class="title">APIServerHandler</span></span> &#123;</span><br><span class="line"><span class="comment">// 采用了 github.com/emicklei/go-restful 这个库作为 RESTful 接口的设计，目前了解即可</span></span><br><span class="line">gorestfulContainer := restful.NewContainer()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="installAPI"><a href="#installAPI" class="headerlink" title="installAPI"></a>installAPI</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">installAPI</span><span class="params">(s *GenericAPIServer, c *Config)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 添加 /index.html 路由规则</span></span><br><span class="line"><span class="keyword">if</span> c.EnableIndex &#123;</span><br><span class="line">routes.Index&#123;&#125;.Install(s.listedPathProvider, s.Handler.NonGoRestfulMux)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 添加go语言 /pprof 的路由规则，常用于性能分析</span></span><br><span class="line"><span class="keyword">if</span> c.EnableProfiling &#123;</span><br><span class="line">routes.Profiling&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class="line"><span class="keyword">if</span> c.EnableContentionProfiling &#123;</span><br><span class="line">goruntime.SetBlockProfileRate(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">routes.DebugFlags&#123;&#125;.Install(s.Handler.NonGoRestfulMux, <span class="string">&quot;v&quot;</span>, routes.StringFlagPutHandler(logs.GlogSetter))</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 添加监控相关的 /metrics 的指标路由规则</span></span><br><span class="line"><span class="keyword">if</span> c.EnableMetrics &#123;</span><br><span class="line"><span class="keyword">if</span> c.EnableProfiling &#123;</span><br><span class="line">routes.MetricsWithReset&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">routes.DefaultMetrics&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加版本 /version 的路由规则</span></span><br><span class="line">routes.Version&#123;Version: c.Version&#125;.Install(s.Handler.GoRestfulContainer)</span><br><span class="line"><span class="comment">// 开启服务发现</span></span><br><span class="line"><span class="keyword">if</span> c.EnableDiscovery &#123;</span><br><span class="line">s.Handler.GoRestfulContainer.Add(s.DiscoveryGroupManager.WebService())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> feature.DefaultFeatureGate.Enabled(features.APIPriorityAndFairness) &#123;</span><br><span class="line">c.FlowControl.Install(s.Handler.NonGoRestfulMux)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Apiserver"><a href="#Apiserver" class="headerlink" title="Apiserver"></a>Apiserver</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">New</span><span class="params">(delegationTarget genericapiserver.DelegationTarget)</span> <span class="params">(*Master, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// genericServer的初始化</span></span><br><span class="line">s, err := c.GenericConfig.New(<span class="string">&quot;kube-apiserver&quot;</span>, delegationTarget)</span><br><span class="line"><span class="comment">// 核心KubeAPIServer的实例化</span></span><br><span class="line">m := &amp;Master&#123;</span><br><span class="line">GenericAPIServer:          s,</span><br><span class="line">ClusterAuthenticationInfo: c.ExtraConfig.ClusterAuthenticationInfo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册Legacy API的注册</span></span><br><span class="line"><span class="keyword">if</span> c.ExtraConfig.APIResourceConfigSource.VersionEnabled(apiv1.SchemeGroupVersion) &#123;</span><br><span class="line">legacyRESTStorageProvider := corerest.LegacyRESTStorageProvider&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := m.InstallLegacyAPI(&amp;c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// REST接口的存储定义，可以看到很多k8s上的常见定义，比如node节点/storage存储/event事件等等</span></span><br><span class="line">restStorageProviders := []RESTStorageProvider&#123;</span><br><span class="line">authenticationrest.RESTStorageProvider&#123;Authenticator: c.GenericConfig.Authentication.Authenticator, APIAudiences: c.GenericConfig.Authentication.APIAudiences&#125;,</span><br><span class="line">authorizationrest.RESTStorageProvider&#123;Authorizer: c.GenericConfig.Authorization.Authorizer, RuleResolver: c.GenericConfig.RuleResolver&#125;,</span><br><span class="line">autoscalingrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">batchrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">certificatesrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">coordinationrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">discoveryrest.StorageProvider&#123;&#125;,</span><br><span class="line">extensionsrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">networkingrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">noderest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">policyrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">rbacrest.RESTStorageProvider&#123;Authorizer: c.GenericConfig.Authorization.Authorizer&#125;,</span><br><span class="line">schedulingrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">settingsrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">storagerest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">flowcontrolrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line"><span class="comment">// keep apps after extensions so legacy clients resolve the extensions versions of shared resource names.</span></span><br><span class="line"><span class="comment">// See https://github.com/kubernetes/kubernetes/issues/42392</span></span><br><span class="line">appsrest.StorageProvider&#123;&#125;,</span><br><span class="line">admissionregistrationrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">eventsrest.RESTStorageProvider&#123;TTL: c.ExtraConfig.EventTTL&#125;,</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 注册API</span></span><br><span class="line"><span class="keyword">if</span> err := m.InstallAPIs(c.ExtraConfig.APIResourceConfigSource, c.GenericConfig.RESTOptionsGetter, restStorageProviders...); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加Hook</span></span><br><span class="line">m.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;start-cluster-authentication-info-controller&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(hookContext genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册API的关键在<code>InstallLegacyAPI</code>和<code>InstallAPIs</code>，如果你对kubernetes的资源有一定的了解，会知道核心资源都放在Legacy中（如果不了解的话，点击函数看一下，就能有所有了解）</p><h2 id="InstallLegacyAPI"><a href="#InstallLegacyAPI" class="headerlink" title="InstallLegacyAPI"></a>InstallLegacyAPI</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">InstallLegacyAPI</span><span class="params">(c *completedConfig, restOptionsGetter generic.RESTOptionsGetter, legacyRESTStorageProvider corerest.LegacyRESTStorageProvider)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// RESTStorage的初始化</span></span><br><span class="line">legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 前缀为 /api，注册上对应的Version和Resource</span></span><br><span class="line">  <span class="comment">// Pod作为核心资源，没有Group的概念</span></span><br><span class="line"><span class="keyword">if</span> err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error in registering group versions: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再细看这个RESTStorage的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c LegacyRESTStorageProvider)</span> <span class="title">NewLegacyRESTStorage</span><span class="params">(restOptionsGetter generic.RESTOptionsGetter)</span> <span class="params">(LegacyRESTStorage, genericapiserver.APIGroupInfo, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// pod 模板</span></span><br><span class="line">podTemplateStorage, err := podtemplatestore.NewREST(restOptionsGetter)</span><br><span class="line"><span class="comment">// event事件</span></span><br><span class="line">eventStorage, err := eventstore.NewREST(restOptionsGetter, <span class="keyword">uint64</span>(c.EventTTL.Seconds()))</span><br><span class="line"><span class="comment">// limitRange资源限制</span></span><br><span class="line">limitRangeStorage, err := limitrangestore.NewREST(restOptionsGetter)</span><br><span class="line"><span class="comment">// resourceQuota资源配额</span></span><br><span class="line">resourceQuotaStorage, resourceQuotaStatusStorage, err := resourcequotastore.NewREST(restOptionsGetter)</span><br><span class="line"><span class="comment">// secret加密</span></span><br><span class="line">secretStorage, err := secretstore.NewREST(restOptionsGetter)</span><br><span class="line"><span class="comment">// PV 存储</span></span><br><span class="line">persistentVolumeStorage, persistentVolumeStatusStorage, err := pvstore.NewREST(restOptionsGetter)</span><br><span class="line"><span class="comment">// PVC 存储</span></span><br><span class="line">persistentVolumeClaimStorage, persistentVolumeClaimStatusStorage, err := pvcstore.NewREST(restOptionsGetter)</span><br><span class="line"><span class="comment">// ConfigMap 配置</span></span><br><span class="line">configMapStorage, err := configmapstore.NewREST(restOptionsGetter)</span><br><span class="line"><span class="comment">// 等等核心资源，暂不一一列举</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// pod模板，我们的示例nginx-pod属于这个类型的资源</span></span><br><span class="line">  podStorage, err := podstore.NewStorage()</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 保存storage的对应关系</span></span><br><span class="line">  restStorageMap := <span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;</span><br><span class="line"><span class="string">&quot;pods&quot;</span>:             podStorage.Pod,</span><br><span class="line"><span class="string">&quot;pods/attach&quot;</span>:      podStorage.Attach,</span><br><span class="line"><span class="string">&quot;pods/status&quot;</span>:      podStorage.Status,</span><br><span class="line"><span class="string">&quot;pods/log&quot;</span>:         podStorage.Log,</span><br><span class="line"><span class="string">&quot;pods/exec&quot;</span>:        podStorage.Exec,</span><br><span class="line"><span class="string">&quot;pods/portforward&quot;</span>: podStorage.PortForward,</span><br><span class="line"><span class="string">&quot;pods/proxy&quot;</span>:       podStorage.Proxy,</span><br><span class="line"><span class="string">&quot;pods/binding&quot;</span>:     podStorage.Binding,</span><br><span class="line"><span class="string">&quot;bindings&quot;</span>:         podStorage.LegacyBinding,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Create-Pod"><a href="#Create-Pod" class="headerlink" title="Create Pod"></a>Create Pod</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看Pod初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStorage</span><span class="params">(optsGetter generic.RESTOptionsGetter, k client.ConnectionInfoGetter, proxyTransport http.RoundTripper, podDisruptionBudgetClient policyclient.PodDisruptionBudgetsGetter)</span> <span class="params">(PodStorage, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">store := &amp;genericregistry.Store&#123;</span><br><span class="line">NewFunc:                  <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span> &#123; <span class="keyword">return</span> &amp;api.Pod&#123;&#125; &#125;,</span><br><span class="line">NewListFunc:              <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span> &#123; <span class="keyword">return</span> &amp;api.PodList&#123;&#125; &#125;,</span><br><span class="line">PredicateFunc:            registrypod.MatchPod,</span><br><span class="line">DefaultQualifiedResource: api.Resource(<span class="string">&quot;pods&quot;</span>),</span><br><span class="line"><span class="comment">// 增改删的策略</span></span><br><span class="line">CreateStrategy:      registrypod.Strategy,</span><br><span class="line">UpdateStrategy:      registrypod.Strategy,</span><br><span class="line">DeleteStrategy:      registrypod.Strategy,</span><br><span class="line">ReturnDeletedObject: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">TableConvertor: printerstorage.TableConvertor&#123;TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查看 Strategy 的初始化</span></span><br><span class="line"><span class="keyword">var</span> Strategy = podStrategy&#123;legacyscheme.Scheme, names.SimpleNameGenerator&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 又查询到Scheme的初始化。Schema可以理解为Kubernetes的注册表，即所有的资源类型必须先注册进Schema才可使用</span></span><br><span class="line"><span class="keyword">var</span> Scheme = runtime.NewScheme()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚焦目标&quot;&gt;&lt;a href=&quot;#聚焦目标&quot; class=&quot;headerlink&quot; title=&quot;聚焦目标&quot;&gt;&lt;/a&gt;聚焦目标&lt;/h2&gt;&lt;p&gt;理解kube-apiserver是中的管理核心资源的&lt;code&gt;KubeAPIServer&lt;/code&gt;是怎么启动的&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【K8s源码品读】004：Phase 1 - kubectl - 发送创建Pod请求的实现细节</title>
    <link href="http://example.com/2021/02/18/k8s-004/"/>
    <id>http://example.com/2021/02/18/k8s-004/</id>
    <published>2021-02-18T08:55:51.000Z</published>
    <updated>2021-02-18T08:58:44.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解kubectl是怎么向kube-apiserver发送请求的</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#send-request">向kube-apiserver发送请求</a></li><li><a href="#RESTful-client">RESTful客户端是怎么创建的</a></li><li><a href="#object">Object是怎么生成的</a></li><li><a href="#post">发送post请求</a></li><li><a href="#summary">kubectl第一阶段源码阅读总结</a></li></ol><h2 id="send-request"><a href="#send-request" class="headerlink" title="send request"></a>send request</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在RunCreate函数中，关键的发送函数</span></span><br><span class="line">obj, err := resource.</span><br><span class="line">NewHelper(info.Client, info.Mapping).</span><br><span class="line">DryRun(o.DryRunStrategy == cmdutil.DryRunServer).</span><br><span class="line">WithFieldManager(o.fieldManager).</span><br><span class="line">Create(info.Namespace, <span class="literal">true</span>, info.Object)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入create函数，查看到</span></span><br><span class="line">m.createResource(m.RESTClient, m.Resource, namespace, obj, options)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的实现为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Helper)</span> <span class="title">createResource</span><span class="params">(c RESTClient, resource, namespace <span class="keyword">string</span>, obj runtime.Object, options *metav1.CreateOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Post().</span><br><span class="line">NamespaceIfScoped(namespace, m.NamespaceScoped).</span><br><span class="line">Resource(resource).</span><br><span class="line">VersionedParams(options, metav1.ParameterCodec).</span><br><span class="line">Body(obj).</span><br><span class="line">Do(context.TODO()).</span><br><span class="line">Get()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">到这里，我们发现了2个关键性的定义:</span></span><br><span class="line"><span class="comment">1. RESTClient 与kube-apiserver交互的RESTful风格的客户端</span></span><br><span class="line"><span class="comment">2. runtime.Object 资源对象的抽象，包括Pod/Deployment/Service等各类资源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="RESTful-Client"><a href="#RESTful-Client" class="headerlink" title="RESTful Client"></a>RESTful Client</h2><p>我们先来看看，与kube-apiserver交互的Client是怎么创建的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从传入参数来看，数据来源于Info这个结构</span></span><br><span class="line">r.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *resource.Info, err error)</span> <span class="title">error</span></span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而info来源于前面的Builder，前面部分都是将Builder参数化，核心的生成为Do函数</span></span><br><span class="line">r := f.NewBuilder().</span><br><span class="line">Unstructured().</span><br><span class="line">Schema(schema).</span><br><span class="line">ContinueOnError().</span><br><span class="line">NamespaceParam(cmdNamespace).DefaultNamespace().</span><br><span class="line">FilenameParam(enforceNamespace, &amp;o.FilenameOptions).</span><br><span class="line">LabelSelectorParam(o.Selector).</span><br><span class="line">Flatten().</span><br><span class="line">Do()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大致看一下这些函数，我们可以在Unstructured()中看到getClient函数，其实这就是我们要找的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">getClient</span><span class="params">(gv schema.GroupVersion)</span> <span class="params">(RESTClient, error)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从返回值来看，client包括默认的REST client和配置选项</span></span><br><span class="line">NewClientWithOptions(client, b.requestTransforms...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个Client会在kubernetes项目中大量出现，它是与kube-apiserver交互的核心组件，以后再深入。</span></span><br></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p><code>Object</code>这个对象是怎么获取到的呢？因为我们的数据源是来自文件的，那么我们最直观的想法就是<code>FileVisitor</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *FileVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 省略读取这块的代码，底层调用的是StreamVisitor的逻辑</span></span><br><span class="line"><span class="keyword">return</span> v.StreamVisitor.Visit(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *StreamVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">d := yaml.NewYAMLOrJSONDecoder(v.Reader, <span class="number">4096</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 这里就是返回info的地方</span></span><br><span class="line">info, err := v.infoForData(ext.Raw, v.Source)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再往下一层看，来到mapper层，也就是kubernetes的资源对象映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *mapper)</span> <span class="title">infoForData</span><span class="params">(data []<span class="keyword">byte</span>, source <span class="keyword">string</span>)</span> <span class="params">(*Info, error)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 这里就是我们返回Object的地方，其中GVK是Group/Version/Kind的缩写，后续我们会涉及</span></span><br><span class="line">  obj, gvk, err := m.decoder.Decode(data, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，我们想回头去看，这个mapper是在什么时候被定义的？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Builder初始化中，我们就找到了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Unstructured</span><span class="params">()</span> *<span class="title">Builder</span></span> &#123;</span><br><span class="line">b.mapper = &amp;mapper&#123;</span><br><span class="line">localFn:      b.isLocal,</span><br><span class="line">restMapperFn: b.restMapperFn,</span><br><span class="line">clientFn:     b.getClient,</span><br><span class="line">    <span class="comment">// 我们查找资源用到的是这个decoder</span></span><br><span class="line">decoder:      &amp;metadataValidatingDecoder&#123;unstructured.UnstructuredJSONScheme&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐层往下找，对应的Decode方法的实现，就是对应的数据解析成data：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s unstructuredJSONScheme)</span> <span class="title">decode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 细节暂时忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><p>了解了<code>REST Client</code>和<code>Object</code>的大致产生逻辑后，我们再回过头来看发送的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RESTful接口风格中，POST请求对应的就是CREATE方法</span></span><br><span class="line">c.Post().</span><br><span class="line">NamespaceIfScoped(namespace, m.NamespaceScoped).</span><br><span class="line">Resource(resource).</span><br><span class="line">VersionedParams(options, metav1.ParameterCodec).</span><br><span class="line">Body(obj).</span><br><span class="line">Do(context.TODO()). </span><br><span class="line">Get() </span><br><span class="line"></span><br><span class="line"><span class="comment">// Do方法，发送请求</span></span><br><span class="line">err := r.request(ctx, <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request, resp *http.Response)</span></span> &#123;</span><br><span class="line">result = r.transformResponse(resp, req)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get方法，获取请求的返回结果，用来打印状态</span></span><br><span class="line"><span class="keyword">switch</span> t := out.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *metav1.Status:</span><br><span class="line"><span class="keyword">if</span> t.Status != metav1.StatusSuccess &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.FromObject(t)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>到这里我们对kubectl的功能有了初步的了解，希望大家对以下的关键内容有所掌握：</p><ol><li>命令行采用了<code>cobra</code>库，主要支持7个大类的命令；</li><li>掌握Visitor设计模式，这个是kubectl实现各类资源对象的解析和校验的核心；</li><li>初步了解<code>RESTClient</code>和<code>Object</code>这两个对象，它们是贯穿kubernetes的核心概念；</li><li>调用逻辑<ol><li>cobra匹配子命令</li><li>用Visitor模式构建Builder</li><li>用RESTClient将Object发送到kube-apiserver</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚焦目标&quot;&gt;&lt;a href=&quot;#聚焦目标&quot; class=&quot;headerlink&quot; title=&quot;聚焦目标&quot;&gt;&lt;/a&gt;聚焦目标&lt;/h2&gt;&lt;p&gt;理解kubectl是怎么向kube-apiserver发送请求的&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【K8s源码品读】005：Phase 1 - kube-apiserver 权限相关的三个核心概念</title>
    <link href="http://example.com/2021/02/18/k8s-005/"/>
    <id>http://example.com/2021/02/18/k8s-005/</id>
    <published>2021-02-18T08:55:51.000Z</published>
    <updated>2021-02-18T08:59:03.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解启动kube-apiserver的权限相关的三个核心概念 <code>Authentication</code>/<code>Authorization</code>/<code>Admission</code></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#run">kube-apiserver的启动</a></li><li><a href="#three-servers">kube-apiserver的三个Server</a></li><li><a href="#KubeAPIServer">KubeAPIServer的创建过程</a><ol><li><a href="#GenericConfig">通用配置概况</a></li><li><a href="#Authentication">通用配置中的认证</a></li><li><a href="#Authorization">通用配置中的授权</a></li><li><a href="#Admission">通用配置中的准入机制</a></li></ol></li></ol><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似kubectl的源代码，kube-apiserver的命令行工具也使用了cobra，我们很快就能找到启动的入口</span></span><br><span class="line">RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里包含2个参数，前者是参数completedOptions，后者是一个stopCh &lt;-chan struct&#123;&#125;</span></span><br><span class="line"><span class="keyword">return</span> Run(completedOptions, genericapiserver.SetupSignalHandler())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在这里，我们可以和kubectl结合起来思考：</span></span><br><span class="line"><span class="comment">kubectl是一个命令行工具，执行完命令就退出；kube-apiserver是一个常驻的服务器进程，监听端口</span></span><br><span class="line"><span class="comment">这里引入了一个stopCh &lt;-chan struct&#123;&#125;，可以在启动后，用一个 &lt;-stopCh 作为阻塞，使程序不退出</span></span><br><span class="line"><span class="comment">用channel阻塞进程退出，对比传统的方法 - 用一个永不退出的for循环，是一个很优雅的实现</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Three-Servers"><a href="#Three-Servers" class="headerlink" title="Three Servers"></a>Three Servers</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在CreateServerChain这个函数下，创建了3个server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateServerChain</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// API扩展服务，主要针对CRD</span></span><br><span class="line">createAPIExtensionsServer()&#123;&#125; </span><br><span class="line">  <span class="comment">// API核心服务，包括常见的Pod/Deployment/Service，我们今天的重点聚焦在这里</span></span><br><span class="line">  <span class="comment">// 我会跳过很多非核心的配置参数，一开始就去研究细节，很影响整体代码的阅读效率</span></span><br><span class="line">CreateKubeAPIServer()&#123;&#125; </span><br><span class="line">  <span class="comment">// API聚合服务，主要针对metrics</span></span><br><span class="line">createAggregatorServer()&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KubeAPIServer"><a href="#KubeAPIServer" class="headerlink" title="KubeAPIServer"></a>KubeAPIServer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建配置的流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateKubeAPIServerConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 创建通用配置genericConfig</span></span><br><span class="line">  genericConfig, versionedInformers, insecureServingInfo, serviceResolver, pluginInitializers, admissionPostStartHook, storageFactory, err := buildGenericConfig(s.ServerRunOptions, proxyTransport)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GenericConfig"><a href="#GenericConfig" class="headerlink" title="GenericConfig"></a>GenericConfig</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用配置的创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGenericConfig</span><span class="params">(s *options.ServerRunOptions,proxyTransport *http.Transport)</span></span>&#123;</span><br><span class="line">  <span class="comment">// Insecure对应的非安全的通信，也就是HTTP</span></span><br><span class="line">  <span class="keyword">if</span> lastErr = s.InsecureServing...</span><br><span class="line">  <span class="comment">// Secure对应的就是HTTPS</span></span><br><span class="line">  <span class="keyword">if</span> lastErr = s.SecureServing...</span><br><span class="line">  <span class="comment">// OpenAPIConfig是对外提供的API文档</span></span><br><span class="line">  genericConfig.OpenAPIConfig = genericapiserver.DefaultOpenAPIConfig()</span><br><span class="line">  <span class="comment">// 这一块是storageFactory的实例化，可以看到采用的是etcd作为存储方案</span></span><br><span class="line">  storageFactoryConfig := kubeapiserver.NewStorageFactoryConfig()</span><br><span class="line">storageFactoryConfig.APIResourceConfig = genericConfig.MergedResourceConfig</span><br><span class="line">completedStorageFactoryConfig, err := storageFactoryConfig.Complete(s.Etcd)</span><br><span class="line">storageFactory, lastErr = completedStorageFactoryConfig.New()</span><br><span class="line">  <span class="comment">// Authentication 认证相关</span></span><br><span class="line">  <span class="keyword">if</span> lastErr = s.Authentication.ApplyTo()...</span><br><span class="line">  <span class="comment">// Authorization 授权相关</span></span><br><span class="line">  genericConfig.Authorization.Authorizer, genericConfig.RuleResolver, err = BuildAuthorizer()</span><br><span class="line">  <span class="comment">// Admission 准入机制</span></span><br><span class="line">  err = s.Admission.ApplyTo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *BuiltInAuthenticationOptions)</span> <span class="title">ApplyTo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 前面都是对认证config进行参数设置，这里才是真正的实例化</span></span><br><span class="line">  authInfo.Authenticator, openAPIConfig.SecurityDefinitions, err = authenticatorConfig.New()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New这块的代码，我们要抓住核心变量authenticators和tokenAuthenticators，也就是各种认证方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(config Config)</span> <span class="title">New</span><span class="params">()</span> <span class="params">(authenticator.Request, *spec.SecurityDefinitions, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 核心变量authenticators和tokenAuthenticators</span></span><br><span class="line"><span class="keyword">var</span> authenticators []authenticator.Request</span><br><span class="line">  <span class="keyword">var</span> tokenAuthenticators []authenticator.Token</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.RequestHeaderConfig != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 1. 添加requestHeader</span></span><br><span class="line">authenticators = <span class="built_in">append</span>(authenticators, authenticator.WrapAudienceAgnosticRequest(config.APIAudiences, requestHeaderAuthenticator))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.ClientCAContentProvider != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 2. 添加ClientCA</span></span><br><span class="line">    authenticators = <span class="built_in">append</span>(authenticators, certAuth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(config.TokenAuthFile) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 3. token 添加tokenfile</span></span><br><span class="line">tokenAuthenticators = <span class="built_in">append</span>(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, tokenAuth))</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4. token 添加 service account，分两种来源</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(config.ServiceAccountKeyFiles) &gt; <span class="number">0</span> &#123;</span><br><span class="line">tokenAuthenticators = <span class="built_in">append</span>(tokenAuthenticators, serviceAccountAuth)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.TokenRequest) &amp;&amp; config.ServiceAccountIssuer != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">tokenAuthenticators = <span class="built_in">append</span>(tokenAuthenticators, serviceAccountAuth)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> config.BootstrapToken &#123;</span><br><span class="line"><span class="keyword">if</span> config.BootstrapTokenAuthenticator != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 5. token 添加 bootstrap</span></span><br><span class="line">tokenAuthenticators = <span class="built_in">append</span>(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, config.BootstrapTokenAuthenticator))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(config.OIDCIssuerURL) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(config.OIDCClientID) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 6. token 添加 oidc</span></span><br><span class="line">    Authenticators = <span class="built_in">append</span>(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, oidcAuth))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(config.WebhookTokenAuthnConfigFile) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 7. token 添加 webhook</span></span><br><span class="line">tokenAuthenticators = <span class="built_in">append</span>(tokenAuthenticators, webhookTokenAuth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8. 组合tokenAuthenticators到tokenAuthenticators中</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(tokenAuthenticators) &gt; <span class="number">0</span> &#123;</span><br><span class="line">tokenAuth := tokenunion.New(tokenAuthenticators...)</span><br><span class="line"><span class="keyword">if</span> config.TokenSuccessCacheTTL &gt; <span class="number">0</span> || config.TokenFailureCacheTTL &gt; <span class="number">0</span> &#123;</span><br><span class="line">tokenAuth = tokencache.New(tokenAuth, <span class="literal">true</span>, config.TokenSuccessCacheTTL, config.TokenFailureCacheTTL)</span><br><span class="line">&#125;</span><br><span class="line">authenticators = <span class="built_in">append</span>(authenticators, bearertoken.New(tokenAuth), websocket.NewProtocolAuthenticator(tokenAuth))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9. 没有任何认证方式且启用了Anonymous</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(authenticators) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> config.Anonymous &#123;</span><br><span class="line"><span class="keyword">return</span> anonymous.NewAuthenticator(), &amp;securityDefinitions, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;securityDefinitions, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10. 组合authenticators</span></span><br><span class="line">authenticator := union.New(authenticators...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> authenticator, &amp;securityDefinitions, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂的Authentication模块的初始化顺序我们看完了，有初步的了解即可，没必要去强制记忆其中的加载顺序。</p><h3 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildAuthorizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 与上面一致，实例化是在这个New中</span></span><br><span class="line">  <span class="keyword">return</span> authorizationConfig.New()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不得不说，Authorizer这块的阅读体验更好</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(config Config)</span> <span class="title">New</span><span class="params">()</span> <span class="params">(authorizer.Authorizer, authorizer.RuleResolver, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 必须传入一个Authorizer机制</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(config.AuthorizationModes) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;at least one authorization mode must be passed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">authorizers   []authorizer.Authorizer</span><br><span class="line">ruleResolvers []authorizer.RuleResolver</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, authorizationMode := <span class="keyword">range</span> config.AuthorizationModes &#123;</span><br><span class="line"><span class="comment">// 具体的mode定义，可以跳转到对应的链接去看，今天不细讲</span></span><br><span class="line"><span class="keyword">switch</span> authorizationMode &#123;</span><br><span class="line"><span class="keyword">case</span> modes.ModeNode:</span><br><span class="line">authorizers = <span class="built_in">append</span>(authorizers, nodeAuthorizer)</span><br><span class="line">ruleResolvers = <span class="built_in">append</span>(ruleResolvers, nodeAuthorizer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> modes.ModeAlwaysAllow:</span><br><span class="line">authorizers = <span class="built_in">append</span>(authorizers, alwaysAllowAuthorizer)</span><br><span class="line">ruleResolvers = <span class="built_in">append</span>(ruleResolvers, alwaysAllowAuthorizer)</span><br><span class="line">      </span><br><span class="line"><span class="keyword">case</span> modes.ModeAlwaysDeny:</span><br><span class="line">authorizers = <span class="built_in">append</span>(authorizers, alwaysDenyAuthorizer)</span><br><span class="line">ruleResolvers = <span class="built_in">append</span>(ruleResolvers, alwaysDenyAuthorizer)</span><br><span class="line">      </span><br><span class="line"><span class="keyword">case</span> modes.ModeABAC:</span><br><span class="line">authorizers = <span class="built_in">append</span>(authorizers, abacAuthorizer)</span><br><span class="line">ruleResolvers = <span class="built_in">append</span>(ruleResolvers, abacAuthorizer)</span><br><span class="line">      </span><br><span class="line"><span class="keyword">case</span> modes.ModeWebhook:</span><br><span class="line">authorizers = <span class="built_in">append</span>(authorizers, webhookAuthorizer)</span><br><span class="line">ruleResolvers = <span class="built_in">append</span>(ruleResolvers, webhookAuthorizer)</span><br><span class="line">      </span><br><span class="line"><span class="keyword">case</span> modes.ModeRBAC:</span><br><span class="line">authorizers = <span class="built_in">append</span>(authorizers, rbacAuthorizer)</span><br><span class="line">ruleResolvers = <span class="built_in">append</span>(ruleResolvers, rbacAuthorizer)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unknown authorization mode %s specified&quot;</span>, authorizationMode)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> union.New(authorizers...), union.NewRuleResolvers(ruleResolvers...), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// ModeAlwaysAllow is the mode to set all requests as authorized</span></span><br><span class="line">ModeAlwaysAllow <span class="keyword">string</span> = <span class="string">&quot;AlwaysAllow&quot;</span></span><br><span class="line"><span class="comment">// ModeAlwaysDeny is the mode to set no requests as authorized</span></span><br><span class="line">ModeAlwaysDeny <span class="keyword">string</span> = <span class="string">&quot;AlwaysDeny&quot;</span></span><br><span class="line"><span class="comment">// ModeABAC is the mode to use Attribute Based Access Control to authorize</span></span><br><span class="line">ModeABAC <span class="keyword">string</span> = <span class="string">&quot;ABAC&quot;</span></span><br><span class="line"><span class="comment">// ModeWebhook is the mode to make an external webhook call to authorize</span></span><br><span class="line">ModeWebhook <span class="keyword">string</span> = <span class="string">&quot;Webhook&quot;</span></span><br><span class="line"><span class="comment">// ModeRBAC is the mode to use Role Based Access Control to authorize</span></span><br><span class="line">ModeRBAC <span class="keyword">string</span> = <span class="string">&quot;RBAC&quot;</span></span><br><span class="line"><span class="comment">// ModeNode is an authorization mode that authorizes API requests made by kubelets.</span></span><br><span class="line">ModeNode <span class="keyword">string</span> = <span class="string">&quot;Node&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Admission"><a href="#Admission" class="headerlink" title="Admission"></a>Admission</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看定义</span></span><br><span class="line">err = s.Admission.ApplyTo()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AdmissionOptions)</span> <span class="title">ApplyTo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.GenericAdmission.ApplyTo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *Plugins)</span> <span class="title">NewFromPlugins</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> _, pluginName := <span class="keyword">range</span> pluginNames &#123;</span><br><span class="line"><span class="comment">// InitPlugin 为初始化的工作</span></span><br><span class="line">plugin, err := ps.InitPlugin(pluginName, pluginConfig, pluginInitializer)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *Plugins)</span> <span class="title">InitPlugin</span><span class="params">(name <span class="keyword">string</span>, config io.Reader, pluginInitializer PluginInitializer)</span> <span class="params">(Interface, error)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 获取plugin</span></span><br><span class="line">  plugin, found, err := ps.getPlugin(name, config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看一下Interface的定义，就是对准入机制的控制</span></span><br><span class="line"><span class="comment">// Interface is an abstract, pluggable interface for Admission Control decisions.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">Handles(operation Operation) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再去看看获取plugin的地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *Plugins)</span> <span class="title">getPlugin</span><span class="params">(name <span class="keyword">string</span>, config io.Reader)</span> <span class="params">(Interface, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">ps.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> ps.lock.Unlock()</span><br><span class="line">  <span class="comment">// 我们再去研究ps.registry这个参数是在哪里被初始化的</span></span><br><span class="line">f, found := ps.registry[name]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来，我们从kube-apiserver启动过程，逐步找到Admission被初始化的地方</span></span><br><span class="line"><span class="comment">// 启动命令</span></span><br><span class="line">command := app.NewAPIServerCommand()</span><br><span class="line"><span class="comment">// server配置</span></span><br><span class="line">s := options.NewServerRunOptions()</span><br><span class="line"><span class="comment">// admission选项</span></span><br><span class="line">Admission:               kubeoptions.NewAdmissionOptions()</span><br><span class="line"><span class="comment">// 注册准入机制</span></span><br><span class="line">RegisterAllAdmissionPlugins(options.Plugins)</span><br><span class="line"><span class="comment">// 准入机制的所有内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterAllAdmissionPlugins</span><span class="params">(plugins *admission.Plugins)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 这里有很多plugin的注册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往上翻，我们能找到所有plugin，也就是准入机制的定义</span></span><br><span class="line"><span class="keyword">var</span> AllOrderedPlugins = []<span class="keyword">string</span>&#123;</span><br><span class="line">admit.PluginName,                        <span class="comment">// AlwaysAdmit</span></span><br><span class="line">autoprovision.PluginName,                <span class="comment">// NamespaceAutoProvision</span></span><br><span class="line">lifecycle.PluginName,                    <span class="comment">// NamespaceLifecycle</span></span><br><span class="line">exists.PluginName,                       <span class="comment">// NamespaceExists</span></span><br><span class="line">scdeny.PluginName,                       <span class="comment">// SecurityContextDeny</span></span><br><span class="line">antiaffinity.PluginName,                 <span class="comment">// LimitPodHardAntiAffinityTopology</span></span><br><span class="line">podpreset.PluginName,                    <span class="comment">// PodPreset</span></span><br><span class="line">limitranger.PluginName,                  <span class="comment">// LimitRanger</span></span><br><span class="line">serviceaccount.PluginName,               <span class="comment">// ServiceAccount</span></span><br><span class="line">noderestriction.PluginName,              <span class="comment">// NodeRestriction</span></span><br><span class="line">nodetaint.PluginName,                    <span class="comment">// TaintNodesByCondition</span></span><br><span class="line">alwayspullimages.PluginName,             <span class="comment">// AlwaysPullImages</span></span><br><span class="line">imagepolicy.PluginName,                  <span class="comment">// ImagePolicyWebhook</span></span><br><span class="line">podsecuritypolicy.PluginName,            <span class="comment">// PodSecurityPolicy</span></span><br><span class="line">podnodeselector.PluginName,              <span class="comment">// PodNodeSelector</span></span><br><span class="line">podpriority.PluginName,                  <span class="comment">// Priority</span></span><br><span class="line">defaulttolerationseconds.PluginName,     <span class="comment">// DefaultTolerationSeconds</span></span><br><span class="line">podtolerationrestriction.PluginName,     <span class="comment">// PodTolerationRestriction</span></span><br><span class="line">exec.DenyEscalatingExec,                 <span class="comment">// DenyEscalatingExec</span></span><br><span class="line">exec.DenyExecOnPrivileged,               <span class="comment">// DenyExecOnPrivileged</span></span><br><span class="line">eventratelimit.PluginName,               <span class="comment">// EventRateLimit</span></span><br><span class="line">extendedresourcetoleration.PluginName,   <span class="comment">// ExtendedResourceToleration</span></span><br><span class="line">label.PluginName,                        <span class="comment">// PersistentVolumeLabel</span></span><br><span class="line">setdefault.PluginName,                   <span class="comment">// DefaultStorageClass</span></span><br><span class="line">storageobjectinuseprotection.PluginName, <span class="comment">// StorageObjectInUseProtection</span></span><br><span class="line">gc.PluginName,                           <span class="comment">// OwnerReferencesPermissionEnforcement</span></span><br><span class="line">resize.PluginName,                       <span class="comment">// PersistentVolumeClaimResize</span></span><br><span class="line">runtimeclass.PluginName,                 <span class="comment">// RuntimeClass</span></span><br><span class="line">certapproval.PluginName,                 <span class="comment">// CertificateApproval</span></span><br><span class="line">certsigning.PluginName,                  <span class="comment">// CertificateSigning</span></span><br><span class="line">certsubjectrestriction.PluginName,       <span class="comment">// CertificateSubjectRestriction</span></span><br><span class="line">defaultingressclass.PluginName,          <span class="comment">// DefaultIngressClass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new admission plugins should generally be inserted above here</span></span><br><span class="line"><span class="comment">// webhook, resourcequota, and deny plugins must go at the end</span></span><br><span class="line"></span><br><span class="line">mutatingwebhook.PluginName,   <span class="comment">// MutatingAdmissionWebhook</span></span><br><span class="line">validatingwebhook.PluginName, <span class="comment">// ValidatingAdmissionWebhook</span></span><br><span class="line">resourcequota.PluginName,     <span class="comment">// ResourceQuota</span></span><br><span class="line">deny.PluginName,              <span class="comment">// AlwaysDeny</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚焦目标&quot;&gt;&lt;a href=&quot;#聚焦目标&quot; class=&quot;headerlink&quot; title=&quot;聚焦目标&quot;&gt;&lt;/a&gt;聚焦目标&lt;/h2&gt;&lt;p&gt;理解启动kube-apiserver的权限相关的三个核心概念 &lt;code&gt;Authentication&lt;/code&gt;/&lt;co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【K8s源码品读】003：Phase 1 - kubectl - 设计模式中Visitor的实现</title>
    <link href="http://example.com/2021/02/18/k8s-003/"/>
    <id>http://example.com/2021/02/18/k8s-003/</id>
    <published>2021-02-18T08:55:50.000Z</published>
    <updated>2021-02-18T08:58:30.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>理解kubectl的核心实现之一：<code>Visitor Design Pattern</code> 访问者模式</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><p><a href="#visitor-design-pattern">什么是访问者模式</a></p></li><li><p><a href="#visitor">kubectl中的Visitor</a></p></li><li><p><a href="#chained">Visitor的链式处理</a></p><ol><li>多个对象聚合为一个对象<ol><li><a href="#VisitorList">VisitorList</a></li><li><a href="#EagerVisitorList">EagerVisitorList </a></li></ol></li><li>多个方法聚合为一个方法<ol><li><a href="#DecoratedVisitor">DecoratedVisitor</a></li><li><a href="#ContinueOnErrorVisitor">ContinueOnErrorVisitor</a></li></ol></li><li>将对象抽象为多个底层对象，逐个调用方法<ol><li><a href="#FlattenListVisitor">FlattenListVisitor</a></li><li><a href="#FilteredVisitor">FilteredVisitor</a></li></ol></li></ol></li><li><p><a href="#implements">Visitor的各类实现</a></p><ol><li><a href="#StreamVisitor">StreamVisitor</a></li><li><a href="#FileVisitor">FileVisitor</a></li><li><a href="#URLVisitor">URLVisitor</a></li><li><a href="#KustomizeVisitor">KustomizeVisitor</a></li></ol></li></ol><h2 id="visitor-design-pattern"><a href="#visitor-design-pattern" class="headerlink" title="visitor design pattern"></a>visitor design pattern</h2><p>在设计模式中，访问者模式的定义为：</p><blockquote><p>允许一个或者多个操作应用到对象上，解耦操作和对象本身</p></blockquote><p>那么，对一个程序来说，具体的表现就是：</p><ol><li>表面：某个对象执行了一个方法</li><li>内部：对象内部调用了多个方法，最后统一返回结果</li></ol><p>举个例子，</p><ol><li>表面：调用一个查询订单的接口</li><li>内部：先从<code>缓存</code>中查询，没查到再去<code>热点数据库</code>查询，还没查到则去<code>归档数据库</code>里查询</li></ol><h2 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h2><p>我们来看看kubeadm中的<code>访问者模式</code>的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Visitor 即为访问者这个对象</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">Visit(VisitorFunc) error</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VisitorFunc对应这个对象的方法，也就是定义中的“操作”</span></span><br><span class="line"><span class="keyword">type</span> VisitorFunc <span class="function"><span class="keyword">func</span><span class="params">(*Info, error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>基本的数据结构很简单，但从当前的数据结构来看，有两个问题：</p><ol><li><code>单个操作</code> 可以直接调用<code>Visit</code>方法，那<code>多个操作</code>如何实现呢？</li><li>在应用<code>多个操作</code>时，如果出现了error，该退出还是继续应用<code>下一个操作</code>呢？</li></ol><h2 id="Chained"><a href="#Chained" class="headerlink" title="Chained"></a>Chained</h2><h3 id="VisitorList"><a href="#VisitorList" class="headerlink" title="VisitorList"></a>VisitorList</h3><p>封装多个Visitor为一个，出现错误就立刻中止并返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VisitorList定义为[]Visitor，又实现了Visit方法，也就是将多个[]Visitor封装为一个Visitor</span></span><br><span class="line"><span class="keyword">type</span> VisitorList []Visitor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发生error就立刻返回，不继续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l VisitorList)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> l &#123;</span><br><span class="line"><span class="keyword">if</span> err := l[i].Visit(fn); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EagerVisitorList"><a href="#EagerVisitorList" class="headerlink" title="EagerVisitorList"></a>EagerVisitorList</h3><p>封装多个Visitor为一个，出现错误暂存下来，全部遍历完再聚合所有的错误并返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EagerVisitorList 也是将多个[]Visitor封装为一个Visitor</span></span><br><span class="line"><span class="keyword">type</span> EagerVisitorList []Visitor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的错误暂存到[]error中，统一聚合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l EagerVisitorList)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">errs := []error(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> l &#123;</span><br><span class="line"><span class="keyword">if</span> err := l[i].Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := fn(info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DecoratedVisitor"><a href="#DecoratedVisitor" class="headerlink" title="DecoratedVisitor"></a>DecoratedVisitor</h3><p>这里借鉴了装饰器的设计模式，将一个Visitor调用多个VisitorFunc方法，封装为调用一个VisitorFunc</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰器Visitor</span></span><br><span class="line"><span class="keyword">type</span> DecoratedVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">visitor    Visitor</span><br><span class="line">decorators []VisitorFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// visitor遍历调用decorators中所有函数，有失败立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v DecoratedVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> v.visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> v.decorators &#123;</span><br><span class="line"><span class="keyword">if</span> err := v.decorators[i](info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fn(info, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ContinueOnErrorVisitor"><a href="#ContinueOnErrorVisitor" class="headerlink" title="ContinueOnErrorVisitor"></a>ContinueOnErrorVisitor</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错依旧继续</span></span><br><span class="line"><span class="keyword">type</span> ContinueOnErrorVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">Visitor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错不立即返回，聚合所有错误后返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ContinueOnErrorVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">errs := []error&#123;&#125;</span><br><span class="line">err := v.Visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := fn(info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(errs) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FlattenListVisitor"><a href="#FlattenListVisitor" class="headerlink" title="FlattenListVisitor"></a>FlattenListVisitor</h2><p>将runtime.ObjectTyper解析成多个runtime.Object，再转换为多个Info，逐个调用VisitorFunc</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FlattenListVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">visitor Visitor</span><br><span class="line">typer   runtime.ObjectTyper</span><br><span class="line">mapper  *mapper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FilteredVisitor"><a href="#FilteredVisitor" class="headerlink" title="FilteredVisitor"></a>FilteredVisitor</h3><p>对Info资源的检验</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过滤的Info</span></span><br><span class="line"><span class="keyword">type</span> FilteredVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">visitor Visitor</span><br><span class="line">filters []FilterFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v FilteredVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> v.visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, filter := <span class="keyword">range</span> v.filters &#123;</span><br><span class="line">      <span class="comment">// 检验Info是否满足条件，出错则退出</span></span><br><span class="line">ok, err := filter(info, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fn(info, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Implements"><a href="#Implements" class="headerlink" title="Implements"></a>Implements</h2><h3 id="StreamVisitor"><a href="#StreamVisitor" class="headerlink" title="StreamVisitor"></a>StreamVisitor</h3><p>最基础的Visitor</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StreamVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 读取信息的来源，实现了Read这个接口，这个&quot;流式&quot;的概念，包括了常见的HTTP、文件、标准输入等各类输入</span></span><br><span class="line">io.Reader</span><br><span class="line">*mapper</span><br><span class="line"></span><br><span class="line">Source <span class="keyword">string</span></span><br><span class="line">Schema ContentValidator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileVisitor"><a href="#FileVisitor" class="headerlink" title="FileVisitor"></a>FileVisitor</h3><p>文件的访问，包括标准输入，底层调用StreamVisitor来访问</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 表示文件路径或者STDIN</span></span><br><span class="line">Path <span class="keyword">string</span></span><br><span class="line">*StreamVisitor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="URLVisitor"><a href="#URLVisitor" class="headerlink" title="URLVisitor"></a>URLVisitor</h3><p>HTTP用GET方法获取数据，底层也是复用StreamVisitor</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> URLVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">URL *url.URL</span><br><span class="line">*StreamVisitor</span><br><span class="line">  <span class="comment">// 提供错误重试次数</span></span><br><span class="line">HttpAttemptCount <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KustomizeVisitor"><a href="#KustomizeVisitor" class="headerlink" title="KustomizeVisitor"></a>KustomizeVisitor</h3><p>自定义的Visitor，针对自定义的文件系统</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KustomizeVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">Path <span class="keyword">string</span></span><br><span class="line">*StreamVisitor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚焦目标&quot;&gt;&lt;a href=&quot;#聚焦目标&quot; class=&quot;headerlink&quot; title=&quot;聚焦目标&quot;&gt;&lt;/a&gt;聚焦目标&lt;/h2&gt;&lt;p&gt;理解kubectl的核心实现之一：&lt;code&gt;Visitor Design Pattern&lt;/code&gt; 访问者模式&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【K8s源码品读】002：Phase 1 - kubectl - create的调用逻辑</title>
    <link href="http://example.com/2021/02/18/k8s-002/"/>
    <id>http://example.com/2021/02/18/k8s-002/</id>
    <published>2021-02-18T08:55:49.000Z</published>
    <updated>2021-02-18T08:58:00.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h2><p>我们的目标是查看<code>kubectl create -f nginx_pod.yaml</code> 这个命令是怎么运行的。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><p><a href="#main">main函数入口</a></p></li><li><p><a href="#match">传入参数与子命令的匹配</a></p></li><li><p><a href="#command">kubectl命令的初始化</a></p></li><li><p><a href="#create">查看create子命令</a></p></li><li><p><a href="#runCreate">runCreate的创建逻辑</a></p></li></ol><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 如果不调用rand.Seed，每次重新运行这个main函数，rand下的函数返回值始终一致</span></span><br><span class="line"><span class="comment">// Seed即随机的种子，每次用时间戳作为种子，就能保证随机性</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建了kubectl命令的默认参数</span></span><br><span class="line">command := cmd.NewDefaultKubectlCommand()</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span><br><span class="line"><span class="comment">// cliflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span><br><span class="line"><span class="comment">// normalize func and add the go flag set by hand.</span></span><br><span class="line">pflag.CommandLine.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)</span><br><span class="line">pflag.CommandLine.AddGoFlagSet(goflag.CommandLine)</span><br><span class="line"><span class="comment">// cliflag.InitFlags()</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 日志的初始化与退出</span></span><br><span class="line">logs.InitLogs()</span><br><span class="line"><span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行command</span></span><br><span class="line"><span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s的命令行工具采用了 cobra 库，具有命令提示等强大功能，比go语言自带的flag强大很多，可参考 github.com/spf13/cobra</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultKubectlCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewDefaultKubectlCommandWithArgs(NewDefaultPluginHandler(plugin.ValidPluginFilenamePrefixes), os.Args, os.Stdin, os.Stdout, os.Stderr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultKubectlCommandWithArgs</span><span class="params">(pluginHandler PluginHandler, args []<span class="keyword">string</span>, in io.Reader, out, errout io.Writer)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">  <span class="comment">// 初始化NewKubectlCommand，采用标准输入、输出、错误输出</span></span><br><span class="line">cmd := NewKubectlCommand(in, out, errout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pluginHandler == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// 这里为传入的参数，即 create -f nginx_pod.yaml 部分</span></span><br><span class="line">cmdPathPieces := args[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用cobra的Find去匹配args</span></span><br><span class="line"><span class="keyword">if</span> _, _, err := cmd.Find(cmdPathPieces); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := HandlePluginCommand(pluginHandler, cmdPathPieces); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(errout, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>代码较长，我选择关键性的内容进行讲解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKubectlCommand</span><span class="params">(in io.Reader, out, err io.Writer)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">warningHandler := rest.NewWarningWriter(err, rest.WarningWriterOptions&#123;Deduplicate: <span class="literal">true</span>, Color: term.AllowsColorOutput(err)&#125;)</span><br><span class="line">warningsAsErrors := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建主命令</span></span><br><span class="line">cmds := &amp;cobra.Command&#123;</span><br><span class="line">Use:   <span class="string">&quot;kubectl&quot;</span>,</span><br><span class="line">Short: i18n.T(<span class="string">&quot;kubectl controls the Kubernetes cluster manager&quot;</span>),</span><br><span class="line">Long: templates.LongDesc(<span class="string">`</span></span><br><span class="line"><span class="string">      kubectl controls the Kubernetes cluster manager.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      Find more information at:</span></span><br><span class="line"><span class="string">            https://kubernetes.io/docs/reference/kubectl/overview/`</span>),</span><br><span class="line">Run: runHelp,</span><br><span class="line"><span class="comment">// 初始化后，在运行指令前的钩子</span></span><br><span class="line">PersistentPreRunE: <span class="function"><span class="keyword">func</span><span class="params">(*cobra.Command, []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">rest.SetDefaultWarningHandler(warningHandler)</span><br><span class="line">      <span class="comment">// 这里是做pprof性能分析，跳转到对应代码可以看到，我们可以用参数 --profile xxx 来采集性能指标，默认保存在当前目录下的profile.pprof中</span></span><br><span class="line"><span class="keyword">return</span> initProfiling()</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="comment">// 运行指令后的钩子</span></span><br><span class="line">PersistentPostRunE: <span class="function"><span class="keyword">func</span><span class="params">(*cobra.Command, []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">      <span class="comment">// 保存pprof性能分析指标</span></span><br><span class="line"><span class="keyword">if</span> err := flushProfiling(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 打印warning条数</span></span><br><span class="line"><span class="keyword">if</span> warningsAsErrors &#123;</span><br><span class="line">count := warningHandler.WarningCount()</span><br><span class="line"><span class="keyword">switch</span> count &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="comment">// no warnings</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%d warning received&quot;</span>, count)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%d warnings received&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="comment">// bash自动补齐功能，可通过 kubectl completion bash 命令查看</span></span><br><span class="line">    <span class="comment">// 具体安装可参考 https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion</span></span><br><span class="line">BashCompletionFunction: bashCompletionFunc,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化Factory接口，工厂模式</span></span><br><span class="line">f := cmdutil.NewFactory(matchVersionKubeConfigFlags)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略实例化的过程代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// kubectl定义了7类命令，结合Message和各个子命令的package名来看</span></span><br><span class="line">groups := templates.CommandGroups&#123;</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 1. 初级命令，包括 create/expose/run/set</span></span><br><span class="line">Message: <span class="string">&quot;Basic Commands (Beginner):&quot;</span>,</span><br><span class="line">Commands: []*cobra.Command&#123;</span><br><span class="line">create.NewCmdCreate(f, ioStreams),</span><br><span class="line">expose.NewCmdExposeService(f, ioStreams),</span><br><span class="line">run.NewCmdRun(f, ioStreams),</span><br><span class="line">set.NewCmdSet(f, ioStreams),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 2. 中级命令，包括explain/get/edit/delete</span></span><br><span class="line">Message: <span class="string">&quot;Basic Commands (Intermediate):&quot;</span>,</span><br><span class="line">Commands: []*cobra.Command&#123;</span><br><span class="line">explain.NewCmdExplain(<span class="string">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class="line">get.NewCmdGet(<span class="string">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class="line">edit.NewCmdEdit(f, ioStreams),</span><br><span class="line"><span class="built_in">delete</span>.NewCmdDelete(f, ioStreams),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 3. 部署命令，包括 rollout/scale/autoscale</span></span><br><span class="line">Message: <span class="string">&quot;Deploy Commands:&quot;</span>,</span><br><span class="line">Commands: []*cobra.Command&#123;</span><br><span class="line">rollout.NewCmdRollout(f, ioStreams),</span><br><span class="line">scale.NewCmdScale(f, ioStreams),</span><br><span class="line">autoscale.NewCmdAutoscale(f, ioStreams),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 4. 集群管理命令，包括 cerfificate/cluster-info/top/cordon/drain/taint</span></span><br><span class="line">Message: <span class="string">&quot;Cluster Management Commands:&quot;</span>,</span><br><span class="line">Commands: []*cobra.Command&#123;</span><br><span class="line">certificates.NewCmdCertificate(f, ioStreams),</span><br><span class="line">clusterinfo.NewCmdClusterInfo(f, ioStreams),</span><br><span class="line">top.NewCmdTop(f, ioStreams),</span><br><span class="line">drain.NewCmdCordon(f, ioStreams),</span><br><span class="line">drain.NewCmdUncordon(f, ioStreams),</span><br><span class="line">drain.NewCmdDrain(f, ioStreams),</span><br><span class="line">taint.NewCmdTaint(f, ioStreams),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 5. 故障排查和调试，包括 describe/logs/attach/exec/port-forward/proxy/cp/auth</span></span><br><span class="line">Message: <span class="string">&quot;Troubleshooting and Debugging Commands:&quot;</span>,</span><br><span class="line">Commands: []*cobra.Command&#123;</span><br><span class="line">describe.NewCmdDescribe(<span class="string">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class="line">logs.NewCmdLogs(f, ioStreams),</span><br><span class="line">attach.NewCmdAttach(f, ioStreams),</span><br><span class="line">cmdexec.NewCmdExec(f, ioStreams),</span><br><span class="line">portforward.NewCmdPortForward(f, ioStreams),</span><br><span class="line">proxy.NewCmdProxy(f, ioStreams),</span><br><span class="line">cp.NewCmdCp(f, ioStreams),</span><br><span class="line">auth.NewCmdAuth(f, ioStreams),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 6. 高级命令，包括diff/apply/patch/replace/wait/convert/kustomize</span></span><br><span class="line">Message: <span class="string">&quot;Advanced Commands:&quot;</span>,</span><br><span class="line">Commands: []*cobra.Command&#123;</span><br><span class="line">diff.NewCmdDiff(f, ioStreams),</span><br><span class="line">apply.NewCmdApply(<span class="string">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class="line">patch.NewCmdPatch(f, ioStreams),</span><br><span class="line">replace.NewCmdReplace(f, ioStreams),</span><br><span class="line">wait.NewCmdWait(f, ioStreams),</span><br><span class="line">convert.NewCmdConvert(f, ioStreams),</span><br><span class="line">kustomize.NewCmdKustomize(ioStreams),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 7. 设置命令，包括label，annotate，completion</span></span><br><span class="line">Message: <span class="string">&quot;Settings Commands:&quot;</span>,</span><br><span class="line">Commands: []*cobra.Command&#123;</span><br><span class="line">label.NewCmdLabel(f, ioStreams),</span><br><span class="line">annotate.NewCmdAnnotate(<span class="string">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class="line">completion.NewCmdCompletion(ioStreams.Out, <span class="string">&quot;&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">groups.Add(cmds)</span><br><span class="line"></span><br><span class="line">filters := []<span class="keyword">string</span>&#123;<span class="string">&quot;options&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alpha相关的子命令</span></span><br><span class="line">alpha := cmdpkg.NewCmdAlpha(f, ioStreams)</span><br><span class="line"><span class="keyword">if</span> !alpha.HasSubCommands() &#123;</span><br><span class="line">filters = <span class="built_in">append</span>(filters, alpha.Name())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">templates.ActsAsRootCommand(cmds, filters, groups...)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代码补全相关</span></span><br><span class="line"><span class="keyword">for</span> name, completion := <span class="keyword">range</span> bashCompletionFlags &#123;</span><br><span class="line"><span class="keyword">if</span> cmds.Flag(name) != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cmds.Flag(name).Annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">cmds.Flag(name).Annotations = <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">cmds.Flag(name).Annotations[cobra.BashCompCustom] = <span class="built_in">append</span>(</span><br><span class="line">cmds.Flag(name).Annotations[cobra.BashCompCustom],</span><br><span class="line">completion,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加其余子命令，包括 alpha/config/plugin/version/api-versions/api-resources/options</span></span><br><span class="line">cmds.AddCommand(alpha)</span><br><span class="line">cmds.AddCommand(cmdconfig.NewCmdConfig(f, clientcmd.NewDefaultPathOptions(), ioStreams))</span><br><span class="line">cmds.AddCommand(plugin.NewCmdPlugin(f, ioStreams))</span><br><span class="line">cmds.AddCommand(version.NewCmdVersion(f, ioStreams))</span><br><span class="line">cmds.AddCommand(apiresources.NewCmdAPIVersions(f, ioStreams))</span><br><span class="line">cmds.AddCommand(apiresources.NewCmdAPIResources(f, ioStreams))</span><br><span class="line">cmds.AddCommand(options.NewCmdOptions(ioStreams.Out))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cmds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCmdCreate</span><span class="params">(f cmdutil.Factory, ioStreams genericclioptions.IOStreams)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">  <span class="comment">// create子命令的相关选项</span></span><br><span class="line">o := NewCreateOptions(ioStreams)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create子命令的相关说明</span></span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">Use:                   <span class="string">&quot;create -f FILENAME&quot;</span>,</span><br><span class="line">DisableFlagsInUseLine: <span class="literal">true</span>,</span><br><span class="line">Short:                 i18n.T(<span class="string">&quot;Create a resource from a file or from stdin.&quot;</span>),</span><br><span class="line">Long:                  createLong,</span><br><span class="line">Example:               createExample,</span><br><span class="line">    <span class="comment">// 验证参数并运行</span></span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> cmdutil.IsFilenameSliceEmpty(o.FilenameOptions.Filenames, o.FilenameOptions.Kustomize) &#123;</span><br><span class="line">ioStreams.ErrOut.Write([]<span class="keyword">byte</span>(<span class="string">&quot;Error: must specify one of -f and -k\n\n&quot;</span>))</span><br><span class="line">defaultRunFunc := cmdutil.DefaultSubCommandRun(ioStreams.ErrOut)</span><br><span class="line">defaultRunFunc(cmd, args)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">cmdutil.CheckErr(o.Complete(f, cmd))</span><br><span class="line">cmdutil.CheckErr(o.ValidateArgs(cmd, args))</span><br><span class="line">      <span class="comment">// 核心的运行代码逻辑是在这里的RunCreate</span></span><br><span class="line">cmdutil.CheckErr(o.RunCreate(f, cmd))</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.RecordFlags.AddFlags(cmd)</span><br><span class="line"></span><br><span class="line">usage := <span class="string">&quot;to use to create the resource&quot;</span></span><br><span class="line">  <span class="comment">// 加入文件名选项的flag -f，保存到o.FilenameOptions.Filenames中，对应上面</span></span><br><span class="line">cmdutil.AddFilenameOptionFlags(cmd, &amp;o.FilenameOptions, usage)</span><br><span class="line">cmdutil.AddValidateFlags(cmd)</span><br><span class="line">cmd.Flags().BoolVar(&amp;o.EditBeforeCreate, <span class="string">&quot;edit&quot;</span>, o.EditBeforeCreate, <span class="string">&quot;Edit the API resource before creating&quot;</span>)</span><br><span class="line">cmd.Flags().Bool(<span class="string">&quot;windows-line-endings&quot;</span>, runtime.GOOS == <span class="string">&quot;windows&quot;</span>,</span><br><span class="line"><span class="string">&quot;Only relevant if --edit=true. Defaults to the line ending native to your platform.&quot;</span>)</span><br><span class="line">cmdutil.AddApplyAnnotationFlags(cmd)</span><br><span class="line">cmdutil.AddDryRunFlag(cmd)</span><br><span class="line">cmd.Flags().StringVarP(&amp;o.Selector, <span class="string">&quot;selector&quot;</span>, <span class="string">&quot;l&quot;</span>, o.Selector, <span class="string">&quot;Selector (label query) to filter on, supports &#x27;=&#x27;, &#x27;==&#x27;, and &#x27;!=&#x27;.(e.g. -l key1=value1,key2=value2)&quot;</span>)</span><br><span class="line">cmd.Flags().StringVar(&amp;o.Raw, <span class="string">&quot;raw&quot;</span>, o.Raw, <span class="string">&quot;Raw URI to POST to the server.  Uses the transport specified by the kubeconfig file.&quot;</span>)</span><br><span class="line">cmdutil.AddFieldManagerFlagVar(cmd, &amp;o.fieldManager, <span class="string">&quot;kubectl-create&quot;</span>)</span><br><span class="line"></span><br><span class="line">o.PrintFlags.AddFlags(cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment">// create的子命令，指定create对象</span></span><br><span class="line">cmd.AddCommand(NewCmdCreateNamespace(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreateQuota(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreateSecret(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreateConfigMap(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreateServiceAccount(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreateService(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreateDeployment(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreateClusterRole(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreateClusterRoleBinding(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreateRole(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreateRoleBinding(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreatePodDisruptionBudget(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreatePriorityClass(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreateJob(f, ioStreams))</span><br><span class="line">cmd.AddCommand(NewCmdCreateCronJob(f, ioStreams))</span><br><span class="line"><span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="runCreate"><a href="#runCreate" class="headerlink" title="runCreate"></a>runCreate</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *CreateOptions)</span> <span class="title">RunCreate</span><span class="params">(f cmdutil.Factory, cmd *cobra.Command)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// f为传入的Factory，主要是封装了与kube-apiserver交互客户端</span></span><br><span class="line">  </span><br><span class="line">schema, err := f.Validator(cmdutil.GetFlagBool(cmd, <span class="string">&quot;validate&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmdNamespace, enforceNamespace, err := f.ToRawKubeConfigLoader().Namespace()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化Builder，这块的逻辑比较复杂，我们先关注文件部分</span></span><br><span class="line">r := f.NewBuilder().</span><br><span class="line">Unstructured().</span><br><span class="line">Schema(schema).</span><br><span class="line">ContinueOnError().</span><br><span class="line">NamespaceParam(cmdNamespace).DefaultNamespace().</span><br><span class="line">  <span class="comment">// 读取文件信息，发现除了支持简单的本地文件，也支持标准输入和http/https协议访问的文件，保存为Visitor</span></span><br><span class="line">FilenameParam(enforceNamespace, &amp;o.FilenameOptions).</span><br><span class="line">LabelSelectorParam(o.Selector).</span><br><span class="line">Flatten().</span><br><span class="line">Do()</span><br><span class="line">err = r.Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">  <span class="comment">// 调用visit函数，创建资源</span></span><br><span class="line">err = r.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *resource.Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 打印结果 xxxx created</span></span><br><span class="line"><span class="keyword">return</span> o.PrintObj(info.Object)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚焦目标&quot;&gt;&lt;a href=&quot;#聚焦目标&quot; class=&quot;headerlink&quot; title=&quot;聚焦目标&quot;&gt;&lt;/a&gt;聚焦目标&lt;/h2&gt;&lt;p&gt;我们的目标是查看&lt;code&gt;kubectl create -f nginx_pod.yaml&lt;/code&gt; 这个命令是怎么运
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【K8s源码品读】001：Phase 1 - 掌握k8s创建pod的基本流程</title>
    <link href="http://example.com/2021/02/18/k8s-001/"/>
    <id>http://example.com/2021/02/18/k8s-001/</id>
    <published>2021-02-18T08:55:48.000Z</published>
    <updated>2021-02-18T08:56:56.742Z</updated>
    
    <content type="html"><![CDATA[<p>部署Kubernetes集群的方法（建议用kubeadm），详细可参考<a href="http://www.junes.tech/?p=150">我的博客</a>，或者可直接参考<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/">官方文档</a>。</p><p>本次分析的源码基于release-1.19。</p><blockquote><p>后续版本如果对某个模块有大改动的话，大家也可以提醒我进行更新</p></blockquote><h2 id="确立目标"><a href="#确立目标" class="headerlink" title="确立目标"></a>确立目标</h2><ol><li>从<code>创建pod</code>的全流程入手，了解各组件的工作内容，组件主要包括<ol><li>kubectl</li><li>kube-apiserver</li><li>etcd</li><li>kube-controller</li><li>kube-scheduler</li><li>kubelet</li></ol></li><li>对<code>核心模块</code>与<code>引用的库</code>有基本的认识，为后续深入做好铺垫</li><li>结合源码，掌握kubernetes的<code>核心概念</code></li></ol><h2 id="写一个Yaml"><a href="#写一个Yaml" class="headerlink" title="写一个Yaml"></a>写一个Yaml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.8</span></span><br></pre></td></tr></table></figure><h2 id="部署Pod"><a href="#部署Pod" class="headerlink" title="部署Pod"></a>部署Pod</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f nginx_pod.yaml</span><br><span class="line"></span><br><span class="line">pod/nginx-pod created</span><br></pre></td></tr></table></figure><p>提示创建成功</p><h2 id="查询Pod"><a href="#查询Pod" class="headerlink" title="查询Pod"></a>查询Pod</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">NAME                               READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-pod                          1/1     Running             0          4m22s</span><br></pre></td></tr></table></figure><p>打印出状态：</p><ul><li>NAME - nginx-pod就是对应上面 <code>metadata.name</code></li><li>READY - 就绪的个数</li><li>STATUS - 当前的状态，RUNNING表示运行中</li><li>RESTARTS - 重启的次数</li><li>AGE - 运行的次数</li></ul><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>整个操作就这么结束了~</p><p>后续的分析，都是基于这个nginx pod的创建示例来的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;部署Kubernetes集群的方法（建议用kubeadm），详细可参考&lt;a href=&quot;http://www.junes.tech/?p=150&quot;&gt;我的博客&lt;/a&gt;，或者可直接参考&lt;a href=&quot;https://kubernetes.io/zh/docs/setup/pr
      
    
    </summary>
    
    
  </entry>
  
</feed>
